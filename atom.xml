<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小曾博客</title>
  
  <subtitle>IT Boy</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiaozeng26.github.io/"/>
  <updated>2020-07-08T10:55:35.490Z</updated>
  <id>https://xiaozeng26.github.io/</id>
  
  <author>
    <name>小曾</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数组模拟队列</title>
    <link href="https://xiaozeng26.github.io/2020/07/08/%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/"/>
    <id>https://xiaozeng26.github.io/2020/07/08/%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/</id>
    <published>2020-07-08T08:42:21.000Z</published>
    <updated>2020-07-08T10:55:35.490Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-队列的介绍"><a href="#1-队列的介绍" class="headerlink" title="1. 队列的介绍"></a>1. 队列的介绍</h1><p>1）队列是一个有序列表，可以用数组或是链表来实现。</p><p>2）遵循先进先出的原则。即：**先进队列的数据，要先取出。后进的要后取出。</p><p>3）示意图：</p><p><img src="/img/DataStructure/%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p><h1 id="2-数组模拟队列思路"><a href="#2-数组模拟队列思路" class="headerlink" title="2. 数组模拟队列思路"></a>2. 数组模拟队列思路</h1><ul><li>队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图，其中maxSize是该队列的最大容量。</li><li>因为队列的输出、输入是分别从前后端来处理的，因此需要两个变量front及rear分别记录队列前后端的下标，front会随着队列的输出而改变，而rear则会随着数据的输入而改变。如图所示：</li></ul><p><img src="/img/DataStructure/%E7%A4%BA%E6%84%8F%E5%9B%BE2.png" alt=""></p><ul><li>当将数据存入队列时称为”addQueue”, addQueue 的处理需要有两个步骤：</li></ul><p>1）将尾指针后移：rear + 1，当 front == rear 【空】</p><p>2）若尾指针 rear 小于队列的最大下标 maxSize -1,则将数据存入rear所指的数组元素中，否则无法存入数据。rear == maxSize - 1 【满】</p><p><strong>【注意】:  队列的实现最重要的就是知道何时队列为空，何时队列为满。</strong></p><h1 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraySimulateQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试一把</span></span><br><span class="line">        <span class="comment">//创建一个队列</span></span><br><span class="line">        ArrayQueue queue = <span class="keyword">new</span> ArrayQueue(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">char</span> key = <span class="string">' '</span>; <span class="comment">//接收用户输入</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//输出一个菜单</span></span><br><span class="line">        <span class="keyword">while</span> (loop)&#123;</span><br><span class="line">            System.out.println(<span class="string">"s(show): 显示队列"</span>);</span><br><span class="line">            System.out.println(<span class="string">"e(exit): 退出程序"</span>);</span><br><span class="line">            System.out.println(<span class="string">"a(add): 添加数据到队列"</span>);</span><br><span class="line">            System.out.println(<span class="string">"g(get): 从队列中取出数据"</span>);</span><br><span class="line">            System.out.println(<span class="string">"h(head): 查看队列头的数据"</span>);</span><br><span class="line">            key = scanner.next().charAt(<span class="number">0</span>);<span class="comment">//这句话表示接收一个字符</span></span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">                    queue.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">                    System.out.println(<span class="string">"请输入一个数："</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'g'</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = queue.getQueue();</span><br><span class="line">                        System.out.printf(<span class="string">"取出的数据是%d\n"</span>,res);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'h'</span>: <span class="comment">//查看队列头数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = queue.headQueue();</span><br><span class="line">                        System.out.printf(<span class="string">"队列头的数据是%d\n"</span>,res);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'e'</span>:  <span class="comment">//退出</span></span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"程序退出~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用数组模拟队列 -- 编写一个ArrayQueue类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr; <span class="comment">//该数组用于存储数据，模拟队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize; <span class="comment">//表示数组的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front; <span class="comment">//队列头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear; <span class="comment">//队列尾</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.创建队列的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> arrMaxSize)</span></span>&#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">        front = -<span class="number">1</span>; <span class="comment">//指向队列头，分析出front是指向队列头的前一个位置</span></span><br><span class="line">        rear = -<span class="number">1</span>;  <span class="comment">//指向队列尾，指向队列尾的数据（即就是队列最后一个数据）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.判断队列是否满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rear == maxSize -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.添加数据到队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">"队列满，不能加入数据~"</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        rear++;<span class="comment">//rear后移</span></span><br><span class="line">        arr[rear] = n;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.获取队列的数据，出队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空，不能取数据"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        front++;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.显示队列的所有数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">"队列是空的，没有数据~"</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"arr[%d]=%d\n"</span>,i,arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.显示队列的头数据，注意并不是取出数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列是空的,没有数据~~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-代码的简单解析"><a href="#4-代码的简单解析" class="headerlink" title="4. 代码的简单解析"></a>4. 代码的简单解析</h1><p>代码中共有七个方法：</p><ol><li>初始化队列的方法：定义队列最大容量，队头指针，队尾指针的位置。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> arrMaxSize)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>判断队列是否为满：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>判断队列是否为空:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>添加数据到队列:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>从队列中获取数据 , 出队列：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>显示队列的所有数据：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>显示队列的头数据，注意并不是取出数据:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="5-问题分析："><a href="#5-问题分析：" class="headerlink" title="5. 问题分析："></a>5. 问题分析：</h1><p>上述方法是可以实现数组模拟队列的效果，但是数组只能使用一次，不能重复的使用，无法实现复用的效果。</p><p>之后会出<strong>数组模拟环形队列</strong>的实现，将会解决这个问题，感兴趣的朋友可以多关注一下…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://xiaozeng26.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组模拟队列" scheme="https://xiaozeng26.github.io/tags/%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>二维数组与稀疏数组的转换</title>
    <link href="https://xiaozeng26.github.io/2020/07/06/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    <id>https://xiaozeng26.github.io/2020/07/06/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-07-06T15:37:36.000Z</published>
    <updated>2020-07-07T01:37:18.627Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-图解"><a href="#1-图解" class="headerlink" title="1. 图解"></a>1. 图解</h1><p><img src="/img/DataStructure/SparseArray.png" alt=""></p><p>这个教程的讲解是以五子棋棋盘落子的应用场景来介绍的，棋盘就相当于一个二维数组，其中 0表示无子，1表示黑子，2表示蓝子。</p><h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h1><h2 id="2-1-二维数组转换成稀疏数组："><a href="#2-1-二维数组转换成稀疏数组：" class="headerlink" title="2.1 二维数组转换成稀疏数组："></a>2.1 二维数组转换成稀疏数组：</h2><ol><li>遍历原始的二维数组，获取有效数据的个数 <strong>sum</strong>；</li><li>根据有效数据个数 <strong>sum</strong> 创建一个稀疏数组 sparseArr int[sum + 1] [3];</li><li>将二维数组的有效数据存入到稀疏数组中；</li></ol><h2 id="2-2-稀疏数组转换成二维数组"><a href="#2-2-稀疏数组转换成二维数组" class="headerlink" title="2.2 稀疏数组转换成二维数组"></a>2.2 稀疏数组转换成二维数组</h2><ol><li>先读取稀疏矩阵的第一行数据，根据第一行数据创建原始的二维数组，比如上图所示 beginArr int[11] [11];</li><li>再读取稀疏数组后面的几行数据，并赋值给原始的二维数组即可；</li></ol><h1 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.sparsearray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建原始的二维数组</span></span><br><span class="line">        <span class="comment">//0:表示没有棋子 1：表示黑子 2：表示蓝子</span></span><br><span class="line">        <span class="keyword">int</span> chessArr1[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chessArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;<span class="comment">//第二行第三列的是黑子</span></span><br><span class="line">        chessArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;<span class="comment">//第三行第四列表示蓝子</span></span><br><span class="line">        <span class="comment">//输出原始的二维数组</span></span><br><span class="line">        System.out.println(<span class="string">"原始的二维数组:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data: row)&#123;</span><br><span class="line">                System.out.printf(<span class="string">"%d\t"</span>,data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将二维数组 转 稀疏数组思路</span></span><br><span class="line">        <span class="comment">//1.遍历原始的二维数组得到有效数据的个数</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(chessArr1[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">                    sum ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"sum="</span> + sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建对应的稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span> sparseArr[][] =  <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//3.给稀疏数组赋值</span></span><br><span class="line">        <span class="comment">//第一行</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把二维数组有效数据遍历赋值给稀疏数组sparseArr中</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//count 用于记录是第几个非0数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(chessArr1[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">                    sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">                    sparseArr[count][<span class="number">2</span>] = chessArr1[i][j];</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出稀疏数组形式</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"转换后得到的稀疏数组："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%d\t%d\t%d\t\n"</span>, sparseArr[i][<span class="number">0</span>],sparseArr[i][<span class="number">1</span>],sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//==========================================================================</span></span><br><span class="line">        <span class="comment">//将稀疏数组恢复成原始的二维数组</span></span><br><span class="line">        <span class="comment">//1.先读取稀疏数组第一行，根据第一行数据，创建原始的二维数组</span></span><br><span class="line">        <span class="keyword">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.读取稀疏数组的后几行(第二行开始)，并赋给原始的二维数组即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt; sparseArr.length ; i++)&#123;</span><br><span class="line">            chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出恢复后的二维数组</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"恢复后的二维数组:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data: row)&#123;</span><br><span class="line">                System.out.printf(<span class="string">"%d\t"</span>,data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果图：</strong></p><p><img src="/img/DataStructure/result1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://xiaozeng26.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="线性结构之数组" scheme="https://xiaozeng26.github.io/tags/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>搭建分布式文件系统之FASTDFS</title>
    <link href="https://xiaozeng26.github.io/2020/06/02/%E6%90%AD%E5%BB%BA%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B9%8BFASTDFS/"/>
    <id>https://xiaozeng26.github.io/2020/06/02/%E6%90%AD%E5%BB%BA%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B9%8BFASTDFS/</id>
    <published>2020-06-02T01:27:23.000Z</published>
    <updated>2020-06-02T05:08:16.125Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-分布式文件系统介绍"><a href="#1-分布式文件系统介绍" class="headerlink" title="1. 分布式文件系统介绍"></a>1. 分布式文件系统介绍</h1><p>概述：FastDFS是一款开源的轻量级分布式文件系统，主要用它来对文件进行管理，功能包括：文件存储、文件同步、文件访问(文件上传、文件下载)等，解决了大容量存储和负载均衡的问题。</p><p>FastDFS服务端有两个角色：<strong>跟踪器(tracker)</strong>和<strong>存储节点(storage)</strong>。</p><p>跟踪器主要做调度工作，在访问上起负载均衡的作用。</p><p>存储节点主要的工作：存储、同步和提供存取接口。</p><p>FastDFS系统结构如下图所示：</p><p><img src="/img/FastDFS/archive.png" alt=""></p><p>工作原理说明：</p><p>跟踪器和存储节点都可以由一台或者多台服务器构成。跟踪器和存储节点中的服务器均可以随时增加或下线而不会影响线上服务。其中跟踪器中的所有服务器都是对等的，可以根据服务器的压力情况随时增加或减少。</p><p>为了支持大容量，存储节点（服务器）采用了分卷（或分组）的组织方式。存储系统由一个或多个卷组成，卷与卷之间的文件是相互独立的，所有卷 的文件容量累加就是整个存储系统中的文件容量。一个卷可以由一台或多台存储服务器组成，一个卷下的存储服务器中的文件都是相同的，卷中的多台存储服务器起 到了冗余备份和负载均衡的作用。</p><p>在卷中增加服务器时，同步已有的文件由系统自动完成，同步完成后，系统自动将新增服务器切换到线上提供服务。</p><p>当存储空间不足或即将耗尽时，可以动态添加卷。只需要增加一台或多台服务器，并将它们配置为一个新的卷，这样就扩大了存储系统的容量。</p><h1 id="2-文件上传流程"><a href="#2-文件上传流程" class="headerlink" title="2. 文件上传流程"></a>2. 文件上传流程</h1><p>FastDFS中的文件标识分为两部分：卷名和文件名，二者缺一不可。</p><p><img src="/img/FastDFS/upload.png" alt=""></p><p>文件上传的交互流程：</p><ol><li>client询问tracker可以执行上传操作的storage，不需要附加参数；</li><li>tracker返回一台可用的storage的ip地址和端口号。</li><li>client直接与storage通讯完成文件上传。</li></ol><h1 id="3-文件下载流程"><a href="#3-文件下载流程" class="headerlink" title="3. 文件下载流程"></a>3. 文件下载流程</h1><p><img src="/img/FastDFS/download.png" alt=""></p><p>文件下载的交互流程：</p><ol><li>client询问tracker下载文件的storage，参数为文件标识(卷名和文件名)。</li><li>tracker返回一台可用的storage；</li><li>client直接和storage通讯完成文件的下载；</li></ol><p><strong>需要说明的是，client为使用FastDFS服务的调用方，client也应该是一台服务器，它对tracker和storage的调用均为服务器间的调用。</strong></p><h1 id="4-搭建服务器"><a href="#4-搭建服务器" class="headerlink" title="4. 搭建服务器"></a>4. 搭建服务器</h1><h2 id="4-1-安装依赖的环境"><a href="#4-1-安装依赖的环境" class="headerlink" title="4.1 安装依赖的环境"></a>4.1 安装依赖的环境</h2><p>安装FastDFS需要先从官网下载源码，然后进行编译，但是编译需要gcc环境，所以需要先安装gcc。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum -y install gcc-c++</span><br></pre></td></tr></table></figure><p>FastDFS依赖于libevent库，需要安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum -y install libevent</span><br></pre></td></tr></table></figure><h2 id="4-2-上传安装文件"><a href="#4-2-上传安装文件" class="headerlink" title="4.2 上传安装文件"></a>4.2 上传安装文件</h2><p>需要的安装文件如下，有需要的朋友就自己寻找到相应官网下载即可。</p><p><img src="/img/FastDFS/package.png" alt=""></p><p>在/usr/local/目录下新建fastdfs目录，然后按住alt+p键即可实现拖进虚拟机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cd &#x2F;usr&#x2F;local</span><br><span class="line"># mkdir fastdfs&#x2F;</span><br><span class="line">按住alt+p,并用cd切换到&#x2F;usr&#x2F;local&#x2F;fastdfs目录下进行拖拽</span><br></pre></td></tr></table></figure><p><img src="/img/FastDFS/alt_p.png" alt=""></p><h2 id="4-3-安装libfastcommon"><a href="#4-3-安装libfastcommon" class="headerlink" title="4.3 安装libfastcommon"></a>4.3 安装libfastcommon</h2><p>libfastcommon是FastDFS官方提供的，libfastcommon包含了FastDFS运行所需要的的一些基础库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># cd &#x2F;usr&#x2F;local&#x2F;fastdfs</span><br><span class="line"># tar -zxvf libfastcommonV1.0.7.tar.gz</span><br><span class="line"># cd libfastcommon-1.0.7</span><br><span class="line"># .&#x2F;make.sh</span><br><span class="line"># .&#x2F;make.sh install</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> <strong>libfastcommon</strong>安装好后会自动将库文件拷贝至<strong>/usr/lib64</strong>下，由于FastDFS程序引用<strong>usr/lib</strong>目录,所以需要将<strong>/usr/lib64</strong>下的库文件拷贝至<strong>/usr/lib</strong>下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cp &#x2F;usr&#x2F;lib64&#x2F;libfastcommon.so &#x2F;usr&#x2F;lib</span><br><span class="line"># ll &#x2F;usr&#x2F;lib</span><br></pre></td></tr></table></figure><h2 id="4-4-安装FastDFS-tracker-storage"><a href="#4-4-安装FastDFS-tracker-storage" class="headerlink" title="4.4 安装FastDFS(tracker + storage)"></a>4.4 安装FastDFS(tracker + storage)</h2><p>此处我们将tracker和storage配置在一台服务器上，真实环境应该要考虑高可用，需要配置在多台服务器上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># cd &#x2F;usr&#x2F;local&#x2F;fastdfs</span><br><span class="line"># tar -zxvf FastDFS_v5.05.tar.gz</span><br><span class="line"># cd FastDFS</span><br><span class="line"># .&#x2F;make.sh</span><br><span class="line"># .&#x2F;make.sh install</span><br></pre></td></tr></table></figure><p><strong>安装成功后将安装目录下的conf下的文件拷贝到/etc/fdfs/下。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cd &#x2F;usr&#x2F;local&#x2F;fastdfs&#x2F;FastDFS&#x2F;conf&#x2F;</span><br><span class="line"># cp * &#x2F;etc&#x2F;fdfs&#x2F;</span><br></pre></td></tr></table></figure><h3 id="4-4-1-安装Tracker服务"><a href="#4-4-1-安装Tracker服务" class="headerlink" title="4.4.1 安装Tracker服务"></a>4.4.1 安装Tracker服务</h3><p> 配置tracker服务。修改/etc/fdfs/tracker.conf文件。</p><p><img src="/img/FastDFS/tracker.png" alt=""></p><p>启动tracker：/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf</p><p>重启使用命令：/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf <strong>restart</strong></p><h3 id="4-4-2-安装storage服务"><a href="#4-4-2-安装storage服务" class="headerlink" title="4.4.2 安装storage服务"></a>4.4.2 安装storage服务</h3><ol><li><p>如果是在不同的服务器安装，则前面的两步需要重新执行。</p></li><li><p>配置storage服务。修改/etc/fdfs /storage.conf</p></li></ol><p><img src="/img/FastDFS/storage_1.png" alt=""></p><p><img src="/img/FastDFS/storage_2.png" alt=""></p><p>启动storage：/usr/bin/fdfs_storaged  /etc/fdfs/storage.conf </p><p>重启storage：/usr/bin/fdfs_storaged  /etc/fdfs/storage.conf <strong>restart</strong></p><h1 id="5-配置客户端"><a href="#5-配置客户端" class="headerlink" title="5. 配置客户端"></a>5. 配置客户端</h1><p>分三步走：</p><ol><li>将/usr/local/FastDFS/client目录下的libfdfsclient.so文件拷贝到/usr/lib/目录</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cd &#x2F;usr&#x2F;local&#x2F;FastDFS&#x2F;client</span><br><span class="line"># cp libfdfsclient.so &#x2F;usr&#x2F;lib&#x2F;</span><br></pre></td></tr></table></figure><ol start="2"><li>修改配置文件/etc/fdfs/client.conf</li></ol><p><img src="/img/FastDFS/client.png" alt=""></p><ol start="3"><li>测试</li></ol><p>在/root/目录下新建hi.html文件，编辑</p><p><img src="/img/FastDFS/hi.html.png" alt=""></p><p>启动tracker和storage，并用客户端上传</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;usr&#x2F;bin&#x2F;fdfs_trackerd &#x2F;etc&#x2F;fdfs&#x2F;tracker.conf</span><br><span class="line"># &#x2F;usr&#x2F;bin&#x2F;fdfs_storaged &#x2F;etc&#x2F;fdfs&#x2F;storage.conf</span><br><span class="line"># &#x2F;usr&#x2F;bin&#x2F;fdfs_test &#x2F;etc&#x2F;fdfs&#x2F;client.conf upload &#x2F;root&#x2F;hi.html</span><br></pre></td></tr></table></figure><p><img src="/img/FastDFS/test.png" alt=""></p><p>然后复制url地址即可访问：</p><p><img src="/img/FastDFS/view.png" alt=""></p><p><strong>注意：第一次访问是访问不到的，从URL地址观察会发现访问的其实就是80默认端口，所以需要让虚拟机的防火墙对80端口开放。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># firewall-cmd --add--service&#x3D;http --permaent</span><br><span class="line"># firewall-cmd --add-port&#x3D;80&#x2F;tcp --permanent</span><br><span class="line"># firewall-cmd --list-all</span><br></pre></td></tr></table></figure><p><img src="/img/FastDFS/port.png" alt=""></p><p>但是开放80端口之后，会发现其实还是访问不到的，因为客户端访问FastDFS会存在一个ftp协议，而url地址使用的是http协议，所以需要配置Nginx和Nginx插件，让客户端去访问Nginx，而Nginx找Nginx插件，Nginx插件去访问FastDFS。这样才能达到预期效果。</p><p><img src="/img/FastDFS/http.png" alt=""></p><h1 id="6-安装Nginx和Nginx插件"><a href="#6-安装Nginx和Nginx插件" class="headerlink" title="6. 安装Nginx和Nginx插件"></a>6. 安装Nginx和Nginx插件</h1><p>Nginx需要依赖一些环境（gcc在前面已经安装，所以这里不用再次安装）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># yum -y install gcc-c++</span><br><span class="line"># yum -y install pcre pcre-devel</span><br><span class="line"># yum -y install zlib zlib-devel</span><br><span class="line"># yum -y install openssl openssl-devel</span><br></pre></td></tr></table></figure><p><strong>安装Nginx和Nginx插件，两者结合</strong></p><ol><li>解压插件压缩包</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -zxvf fastdfs-nginx-module_v1.16.tar.gz</span><br></pre></td></tr></table></figure><ol start="2"><li>修改fastdfs_nginx_module/src/config文件，把其中的local去掉。</li></ol><p><img src="/img/FastDFS/config.png" alt=""></p><ol start="3"><li>把fastdfs-nginx-module/src/mod_fastdfs.conf文件复制到/etc/fdfs目录下。并编辑该文件：</li></ol><p><img src="/img/FastDFS/mod.png" alt=""></p><ol start="4"><li>解压Nginx，进入其目录。</li><li>给Nginx添加插件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#.&#x2F;configure --add-module&#x3D;&#x2F;usr&#x2F;local&#x2F;soft&#x2F;fastdfs-nginx-module&#x2F;src</span><br></pre></td></tr></table></figure><ol start="6"><li>make </li><li>make install</li></ol><p><strong>注意：Nginx默认安装路径是/usr/local/nginx目录下，所以进入此目录中</strong></p><ol start="8"><li>Nginx的配置  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf</span><br></pre></td></tr></table></figure><p>在nginx的配置文件中添加一个location：</p><p><img src="/img/FastDFS/nginx.png" alt=""></p><ol start="9"><li>启动nginx</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;</span><br><span class="line"># .&#x2F;nginx</span><br><span class="line"># ps -ef | gerep nginx</span><br></pre></td></tr></table></figure><p><img src="/img/FastDFS/ps.png" alt=""></p><h1 id="7-测试上传访问"><a href="#7-测试上传访问" class="headerlink" title="7. 测试上传访问"></a>7. 测试上传访问</h1><p>将一张图片拖入/root目录：</p><p><img src="/img/FastDFS/in.png" alt=""></p><p>开启tracker和storage，并上传</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;usr&#x2F;bin&#x2F;fdfs_trackerd &#x2F;etc&#x2F;fdfs&#x2F;tracker.conf</span><br><span class="line"># &#x2F;usr&#x2F;bin&#x2F;fdfs_storaged &#x2F;etc&#x2F;fdfs&#x2F;storage.conf</span><br><span class="line"># &#x2F;usr&#x2F;bin&#x2F;fdfs_test &#x2F;etc&#x2F;fdfs&#x2F;client.conf upload &#x2F;root&#x2F;3301.jfif</span><br></pre></td></tr></table></figure><p><img src="/img/FastDFS/ok.png" alt=""></p><p>尝试访问：</p><p><img src="/img/FastDFS/success.png" alt=""></p><p>成功！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="FastDFS" scheme="https://xiaozeng26.github.io/tags/FastDFS/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo的入门案例</title>
    <link href="https://xiaozeng26.github.io/2020/05/25/Dubbo%E7%9A%84%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/"/>
    <id>https://xiaozeng26.github.io/2020/05/25/Dubbo%E7%9A%84%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/</id>
    <published>2020-05-25T07:09:36.000Z</published>
    <updated>2020-05-25T14:32:34.581Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-Dubbo的简介"><a href="#1-Dubbo的简介" class="headerlink" title="1. Dubbo的简介"></a>1. Dubbo的简介</h1><p>Apache Dubbo是一款高性能的Java RPC框架。其前身是阿里巴巴公司开源的一个高性能、轻量级的开源Java RPC框架，可以和Spring框架无缝集成。</p><p><strong>什么是RPC ?</strong></p><p>RPC【Remote Procedure Call】是指<strong>远程过程调用</strong>，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</p><p><strong>RPC基本原理</strong></p><p><img src="/img/Dubbo/RPC.png" alt=""></p><p><img src="/img/Dubbo/clientStub.png" alt=""></p><p>根据以上的架构图，做一下解释 : </p><p><strong>客户端消费者的一个功能想要去调用服务端提供者的一个功能时，client functions会去找到一个小助手client stub,而这个小助手会跟服务器建立一个sockets连接，然后将需要调用服务器的方法或者参数传给服务器，服务器端的server stub小助手就会收到这些信息，就会知道客户端要调用服务端的哪个方法以及需要的参数信息也会通过网络传输进服务器端。服务端的小助手就会帮调用需求的方法，获取返回值后通过网络传输给小助手，小助手交给客户端的功能代码。</strong></p><p>总结 ：其实RPC核心就是两个A、B服务器之间建立连接，并进行通信。</p><p>Dubbo官网地址 : <a href="http://dubbo.apache.org/en-us/" target="_blank" rel="noopener">http://dubbo.apache.org/en-us/</a></p><p>Dubbo提供了三大核心能力 : <strong>面向接口的远程方法调用，智能容错和负载均衡，</strong>以及<strong>服务自动注册和发现。</strong></p><h1 id="2-Dubbo的架构说明"><a href="#2-Dubbo的架构说明" class="headerlink" title="2.Dubbo的架构说明"></a>2.Dubbo的架构说明</h1><p>架构图 :</p><p><img src="/img/Dubbo/DubboArchitecture.png" alt=""></p><p><strong>服务提供者（Provider）</strong>：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</p><p><strong>服务消费者（Consumer）</strong>:  调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务。服务消费者，从服务提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p><p><strong>注册中心（Registry）</strong>:  注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</p><p><strong>监控中心（Monitor）</strong>:  服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p><p>调用关系说明 ： </p><ul><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ul><h1 id="3-Dubbo的Hello-World"><a href="#3-Dubbo的Hello-World" class="headerlink" title="3. Dubbo的Hello World"></a>3. Dubbo的Hello World</h1><p>Dubbo作为一个RPC框架，其最核心的功能就是要实现跨网络的远程调用。现在要创建两个应用，一个作为服务的提供者，一个作为服务的消费者。通过Dubbo来实现服务消费者远程调用服务提供者的方法。</p><p>需要创建两个服务模块进行测试 ： </p><table><thead><tr><th>模块</th><th>功能</th></tr></thead><tbody><tr><td>订单服务web模块</td><td>创建订单等</td></tr><tr><td>用户服务service模块</td><td>查询用户地址等</td></tr></tbody></table><p>测试预期结果： </p><p>​        订单服务模块在A服务器，用户服务模块在B服务器，当订单模块需要下订单时，会生成用户地址信息，达到A可以远程调用B的功能。</p><p>项目目录结构图 ： </p><p><img src="/img/Dubbo/HelloWorld.png" alt=""></p><p><strong>注意：</strong>看上面的目录结构图中并没有实体类与接口，那是因为已经将其抽取出来做成一个Module，只需要通过Maven去install成jar,然后通过导入依赖的形式写入module即可。</p><p><img src="/img/Dubbo/api.png" alt=""></p><p><img src="/img/Dubbo/install.png" alt=""></p><p>然后每一个模块都加入相关依赖即可，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.self&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;<span class="class"><span class="keyword">interface</span>-<span class="title">api</span>&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line"><span class="class">      &lt;<span class="title">version</span>&gt;1.0-<span class="title">SNAPSHOT</span>&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-1-公共代码块"><a href="#3-1-公共代码块" class="headerlink" title="3.1 公共代码块"></a><strong>3.1 公共代码块</strong></h2><p>创建一个空的工程，然后<strong>将src目录删除,</strong>在新建一个Module ：interface-api , </p><p>实体类 ： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.dubbo.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAddress</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String userAddress;  <span class="comment">//用户地址</span></span><br><span class="line">    <span class="keyword">private</span> String userId; <span class="comment">//用于ID</span></span><br><span class="line">    <span class="keyword">private</span> String consignee; <span class="comment">//收货人</span></span><br><span class="line">    <span class="keyword">private</span> String phoneNum; <span class="comment">//电话号码</span></span><br><span class="line">    <span class="keyword">private</span> String isDefault; <span class="comment">//是否为默认地址  Y-是  N-否</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserAddress</span><span class="params">(Integer id, String userAddress, String userId, String consignee, String phoneNum, String isDefault)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.userAddress = userAddress;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">        <span class="keyword">this</span>.consignee = consignee;</span><br><span class="line">        <span class="keyword">this</span>.phoneNum = phoneNum;</span><br><span class="line">        <span class="keyword">this</span>.isDefault = isDefault;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserAddress</span><span class="params">(String userAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userAddress = userAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserId</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConsignee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> consignee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConsignee</span><span class="params">(String consignee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.consignee = consignee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPhoneNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> phoneNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhoneNum</span><span class="params">(String phoneNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phoneNum = phoneNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIsDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isDefault;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsDefault</span><span class="params">(String isDefault)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isDefault = isDefault;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"UserAddress&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", userAddress='"</span> + userAddress + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", userId='"</span> + userId + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", consignee='"</span> + consignee + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", phoneNum='"</span> + phoneNum + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", isDefault='"</span> + isDefault + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务层接口 ： </p><p>订单 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.dubbo.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户ID初始化订单</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initOrder</span><span class="params">(String userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户 ： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.dubbo.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.self.dubbo.bean.UserAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户服务接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据ID获取所有收货地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;UserAddress&gt; <span class="title">getUserAddressList</span><span class="params">(String userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-服务提供者"><a href="#3-2-服务提供者" class="headerlink" title="3.2 服务提供者"></a>3.2 服务提供者</h2><p>第一步： 再新建一个Module ： user-service-provider，在pom.xml文件中导入坐标 : </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- 导入Dubbo依赖 --&gt;</span><br><span class="line">      &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/com.alibaba/dubbo --&gt;</span></span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;dubbo&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;2.6.2&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">     &lt;!-- 注册中心使用的是Zookeeper，引入Zookeeper客户端 --&gt;</span><br><span class="line">      &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.apache.curator/curator-framework --&gt;</span></span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;4.0.1&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.self&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;<span class="class"><span class="keyword">interface</span>-<span class="title">api</span>&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line"><span class="class">          &lt;<span class="title">version</span>&gt;1.0-<span class="title">SNAPSHOT</span>&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="class">      &lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line"><span class="class">  &lt;/<span class="title">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步 ： 编写用户接口UserService的实现类 ： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.dubbo.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.self.dubbo.bean.UserAddress;</span><br><span class="line"><span class="keyword">import</span> com.self.dubbo.service.UserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">getUserAddressList</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        UserAddress address1 = <span class="keyword">new</span> UserAddress(<span class="number">1</span>,<span class="string">"广西省防城港"</span>,<span class="string">"1"</span>,<span class="string">"张三"</span>,<span class="string">"123456"</span>,<span class="string">"Y"</span>);</span><br><span class="line">        UserAddress address2 = <span class="keyword">new</span> UserAddress(<span class="number">2</span>,<span class="string">"广西省桂林市"</span>,<span class="string">"1"</span>,<span class="string">"李四"</span>,<span class="string">"456789"</span>,<span class="string">"Y"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(address1,address2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步： 编写Spring与Dubbo整合的provider.xml配置文件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xmlns:dubbo=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span><br><span class="line">       xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"</span></span><br><span class="line"><span class="string">                http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">                http://www.springframework.org/schema/beans/spring-beans-4.3.xsd</span></span><br><span class="line"><span class="string">                http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- <span class="number">1</span>.指定当前服务/应用的名称 --&gt;</span><br><span class="line">    &lt;dubbo:application name="user-service-provider"&gt;&lt;/dubbo:application&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- <span class="number">2</span>.指定注册中心的位置 --&gt;</span><br><span class="line">    &lt;dubbo:registry address="zookeeper://127.0.0.1:2181"&gt;&lt;/dubbo:registry&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- <span class="number">3</span>.指定服务消费者与服务提供者的通信规则(通信协议？通信端口) --&gt;</span><br><span class="line">    &lt;dubbo:protocol name="dubbo" port="20880"&gt;&lt;/dubbo:protocol&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- <span class="number">4</span>.暴露服务(暴露的接口全类名，接口的真正实现对象用ref指定) --&gt;</span><br><span class="line">    &lt;dubbo:service interface="com.self.dubbo.service.UserService" ref="userService"&gt;&lt;/dubbo:service&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- <span class="number">5</span>.服务的真正实现对象 --&gt;</span><br><span class="line">    &lt;bean id="userService" class="com.self.dubbo.service.impl.UserServiceImpl"&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>第四步 ： 编写启动服务提供者的Main方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.dubbo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext ioc = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"provider.xml"</span>);</span><br><span class="line">        ioc.start();</span><br><span class="line"></span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行Main方法后，打开dubbo-admin管理控制台就会发现服务提供者已经注册进Zookeeper</p><p><img src="/img/Dubbo/provider1.png" alt=""></p><p><img src="/img/Dubbo/provider2.png" alt=""></p><h2 id="3-3-服务消费者"><a href="#3-3-服务消费者" class="headerlink" title="3.3 服务消费者"></a>3.3 服务消费者</h2><p>第一步： 再新建一个Module ：order-service-consumer ，在pom.xml文件中导入坐标 : </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.2.5.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 导入Dubbo依赖 --&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/com.alibaba/dubbo --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;dubbo&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.6.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- 注册中心使用的是Zookeeper，引入Zookeeper客户端 --&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.apache.curator/curator-framework --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.0.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.self&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;<span class="class"><span class="keyword">interface</span>-<span class="title">api</span>&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">version</span>&gt;1.0-<span class="title">SNAPSHOT</span>&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步 :  编写订单接口OrderService的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.dubbo.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.self.dubbo.bean.UserAddress;</span><br><span class="line"><span class="keyword">import</span> com.self.dubbo.service.OrderService;</span><br><span class="line"><span class="keyword">import</span> com.self.dubbo.service.UserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Dubbo实现RPC的步骤 :</span></span><br><span class="line"><span class="comment"> *      1. 将服务提供者注册到服务注册中心（暴露服务）</span></span><br><span class="line"><span class="comment"> *          1). 导入Dubbo依赖(2.6.2),操作Zookeeper的客户端(curator)</span></span><br><span class="line"><span class="comment"> *          2). 配置服务提供者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      2. 让服务消费者去注册中心订阅服务提供者的服务地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"orderService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>(required = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initOrder</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"用户ID : "</span> + userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.查询用户的收货地址</span></span><br><span class="line">        List&lt;UserAddress&gt; addressList = userService.getUserAddressList(userId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (UserAddress address : addressList) &#123;</span><br><span class="line">            System.out.println(address.getUserAddress());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步： 编写Spring与Dubbo整合的consumer.xml配置文件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xmlns:dubbo=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span><br><span class="line">       xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans/spring-beans-4.3.xsd</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">       https://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="line"><span class="string">       http://dubbo.apache.org/schema/dubbo</span></span><br><span class="line"><span class="string">       http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:component-scan base-package="com.self.dubbo.service.impl"&gt;&lt;/context:component-scan&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- <span class="number">1</span>. 指定当前应用的名称 --&gt;</span><br><span class="line">    &lt;dubbo:application name="order-service-consumer"&gt;&lt;/dubbo:application&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- <span class="number">2</span>.指定注册中心的位置 --&gt;</span><br><span class="line">    &lt;dubbo:registry address="zookeeper://127.0.0.1:2181"&gt;&lt;/dubbo:registry&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- <span class="number">3</span>. 声明需要调用的远程服务接口，生成远程服务代理 --&gt;</span><br><span class="line">    &lt;dubbo:reference id="userService" interface="com.self.dubbo.service.UserService" &gt;&lt;/dubbo:reference&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>第四步 ： 编写启动服务消费者的Main方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.dubbo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.self.dubbo.service.OrderService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext ioc = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"consumer.xml"</span>);</span><br><span class="line"></span><br><span class="line">        OrderService orderService = ioc.getBean(<span class="string">"orderService"</span>, OrderService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        orderService.initOrder(<span class="string">"1"</span>);</span><br><span class="line">        System.out.println(<span class="string">"调用完成..."</span>);</span><br><span class="line">        System.in.read();<span class="comment">//阻塞</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行Main方法后，就会发现idea控制台有输出结果，说明订单模块已经成功调用用户模块：</p><p> <img src="/img/Dubbo/consumer.png" alt=""></p><p>打开dubbo-admin管理控制台 ： </p><p><img src="/img/Dubbo/admin1.png" alt=""></p><p><img src="/img/Dubbo/admin2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Dubbo" scheme="https://xiaozeng26.github.io/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo-admin的管理控制台的搭建</title>
    <link href="https://xiaozeng26.github.io/2020/05/24/Dubbo-admin%E7%9A%84%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>https://xiaozeng26.github.io/2020/05/24/Dubbo-admin%E7%9A%84%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%9A%84%E6%90%AD%E5%BB%BA/</id>
    <published>2020-05-24T14:55:29.000Z</published>
    <updated>2020-05-24T15:43:07.276Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这里介绍的dubbo-admin管理控制台的搭建首先要装有Zookeeper，Maven。Zookeeper的安装可以看我发布的“Zookeeper的下载与安装”，觉得还是挺详细的了，而Maven这里不做过多的伸展说明。</p><h1 id="1-下载dubbo-admin"><a href="#1-下载dubbo-admin" class="headerlink" title="1. 下载dubbo-admin"></a>1. 下载dubbo-admin</h1><p>下载地址: <a href="https://github.com/apache/dubbo-admin/tree/master" target="_blank" rel="noopener">https://github.com/apache/dubbo-admin/tree/master</a></p><p><img src="/img/Dubbo/clone.png" alt=""></p><p>解压文件夹到无中文的目录下</p><p><img src="/img/Dubbo/ok.png" alt=""></p><p>进入dubbo-admin会发现这是一个Maven的目录结构，然后找到resources目录下的application.properties进行修改 : </p><p><img src="/img/Dubbo/resources.png" alt=""></p><p><img src="/img/Dubbo/register.png" alt=""></p><p>修改完成后我们需要将项目打成jar包,在项目根目录下执行cmd,</p><p>执行打包命令 :  mvn clean package</p><p><img src="/img/Dubbo/package.png" alt=""></p><p>这样打包会比较慢，请耐心等待~</p><p><img src="/img/Dubbo/success.png" alt=""></p><p>这里就打包成功了，然后我们找到target目录下就会看到打好的jar包</p><p><img src="/img/Dubbo/jar.png" alt=""></p><h1 id="2-运行jar包并进入管理控制台"><a href="#2-运行jar包并进入管理控制台" class="headerlink" title="2. 运行jar包并进入管理控制台"></a>2. 运行jar包并进入管理控制台</h1><p><strong>注意：</strong>在运行jar包之前需要先启动Zookeeper服务，不然dubbo-admin会因为找不到zookeeper管理中心而报错。</p><p><img src="/img/Dubbo/start.png" alt=""></p><p>直接在目录的地址栏中执行cmd命令，进入cmd窗口后执行对应的启动命令即可。</p><p><img src="/img/Dubbo/zkServer.png" alt=""></p><p><img src="/img/Dubbo/zkCli.png" alt=""></p><p>然后在dubbo-admin-0.0.1-SNAPSHOT.jar的根目录下，使用cmd命令行执行: <strong>java -jar dubbo-admin-0.0.1-SNAPSHOT.jar</strong>  ，运行项目。</p><p><img src="/img/Dubbo/java-jar.png" alt=""></p><p>会发现服务已经在默认端口7001启动 : </p><p><img src="/img/Dubbo/7001.png" alt=""></p><p>我们可以在网页访问一下控制台：<br>访问地址就是：<strong><a href="http://localhost:7001/" target="_blank" rel="noopener">http://localhost:7001/</a></strong><br>默认的用户名和密码都是 ：<strong>root</strong></p><p><img src="/img/Dubbo/in.png" alt=""></p><p><img src="/img/Dubbo/page.png" alt=""></p><p>现在就登录成功了！</p><p>到此为止，dubbo-admin管理控制台的搭建就完成了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Dubbo" scheme="https://xiaozeng26.github.io/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper的下载与安装</title>
    <link href="https://xiaozeng26.github.io/2020/05/24/Zookeeper%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
    <id>https://xiaozeng26.github.io/2020/05/24/Zookeeper%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85/</id>
    <published>2020-05-24T02:21:48.000Z</published>
    <updated>2020-05-24T04:20:33.896Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>​            Zookeeper是一个开源的分布式的项目，用于管理服务提供者的注册信息。</p><p>​            Zookeeper = 文件系统 + 通知机制</p><h1 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h1><ul><li>Zookeeper : 一个领导者(Leader),多个跟随者(Follower)组成的集群。</li><li><strong>集群中只有半数以上节点存活，Zookeeper集群才能正常服务。</strong></li><li>全局数据一致 : 每个Server保存一份相同的数据副本，Client无论连接到哪一个Server，数据都是一致的。</li><li>更新请求和顺序执行 : 来自同一个Client的更新请求按其发送顺序依次执行。</li><li>数据更新原子性 :  一次数据更新要么成功，要么失败。</li><li>实时性 : 在一定时间范围内，Client能读到最新数据。</li></ul><h1 id="3-Zookeeper的数据结构"><a href="#3-Zookeeper的数据结构" class="headerlink" title="3. Zookeeper的数据结构"></a>3. Zookeeper的数据结构</h1><p>​                Zookeeper数据模型，整体上可以看作是一棵树，每个节点称作一个ZNode，每一个ZNode默认能够存储<strong>1MB</strong>的数据，<strong>每个ZNode都可以通过其路径唯一标识。</strong></p><p><img src="/img/Zookeeper/mode.png" alt=""></p><h1 id="4-基于Windows的Zookeeper安装"><a href="#4-基于Windows的Zookeeper安装" class="headerlink" title="4. 基于Windows的Zookeeper安装"></a>4. 基于Windows的Zookeeper安装</h1><p>1.下载地址 : <a href="https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.6.1/apache-zookeeper-3.6.1-bin.tar.gz" target="_blank" rel="noopener">https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.6.1/apache-zookeeper-3.6.1-bin.tar.gz</a></p><p>2.将下载下来的.tar.gz解压到不含中文的目录，并进入Zookeeper根目录下的bin目录。</p><p><img src="/img/Zookeeper/bin.png" alt=""></p><p>3.在bin目录下的地址栏输入cmd,进入命令行窗口并执行zkServer.cmd</p><p><img src="/img/Zookeeper/zoo.png" alt=""></p><p>如果报了以上的错误，说明需要在conf目录下做修改 ：</p><p><img src="/img/Zookeeper/conf.png" alt=""></p><p>将文件夹下的zoo_sample.cfg文件复制一份副本，并更名为zoo.cfg。</p><p>编辑zoo.cfg,更改dataDir参数，并在Zookeeper目录下创建data目录 ： </p><p><img src="/img/Zookeeper/vimZoo.png" alt=""></p><p><img src="/img/Zookeeper/data.png" alt=""></p><p>4.然后重新进入bin目录启动Zookeeper服务器，并用客户端连接 : </p><p><img src="/img/Zookeeper/start.png" alt=""></p><p>启动Server时出现Zookeeper的图标，说明启动成功。</p><p><img src="/img/Zookeeper/conn.png" alt=""></p><p>客户端连接成功</p><h1 id="5-基于Linux的Zookeeper安装"><a href="#5-基于Linux的Zookeeper安装" class="headerlink" title="5.基于Linux的Zookeeper安装"></a>5.基于Linux的Zookeeper安装</h1><p>*<em>注意: *</em> 安装Zookeeper之前先要安装jdk</p><p>1.在/opt目录下新建software,和module目录，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mkdir &#x2F;opt&#x2F;software</span><br><span class="line"># mkdir &#x2F;opt&#x2F;module</span><br></pre></td></tr></table></figure><p>2.按住alt + p进入文件传输窗口，将Zookeeper和jdk的.tar.gz拖进/opt/software/</p><p>3.将/opt/software中的Zookeeper包解压到/opt/module目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -zxvf jdk-8u144-linux-x64.tar.gz -C &#x2F;opt&#x2F;module&#x2F;</span><br></pre></td></tr></table></figure><p>4.配置环境变量</p><p>进入jdk目录，用pwd命令获取其路径，然后编辑/etc/profile</p><p>在profile文件底部加入以下内容: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">##JAVA_HOME</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;opt&#x2F;module&#x2F;jdk1.8.0_144</span><br><span class="line">export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin</span><br></pre></td></tr></table></figure><p>记住，写入之后需要先编译以下才能生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># java -version</span><br></pre></td></tr></table></figure><p><img src="/img/Zookeeper/java.png" alt=""></p><p>出现以上信息代表安装成功</p><p>5.解压Zookeeper软件包到/opt/module目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -zxvf apache-zookeeper-3.6.1-bin.tar.gz -C &#x2F;opt&#x2F;module&#x2F;</span><br></pre></td></tr></table></figure><p>6.修改配置</p><p>将/opt/module/apache-zookeeper-3.6.1-bin/conf路径下的zoo_sample.cfg更名为zoo.cfg;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mv zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure><p>打开zoo.cfg文件，修改dataDir路径 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vim zoo.cfg</span><br></pre></td></tr></table></figure><p>​        修改如下内容 :</p><p>​            dataDir=/opt/module/apache-zookeeper-3.6.1-bin/zkData</p><p>在/opt/module/apache-zookeeper-3.6.1-bin/目录下创建zkData文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir zkData</span><br></pre></td></tr></table></figure><p>7.启动Linux版的Zookeeper服务端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># bin&#x2F;zkServer.sh start</span><br><span class="line"># ps -ef | grep zookeeper</span><br></pre></td></tr></table></figure><p><img src="/img/Zookeeper/zoo_linux.png" alt=""></p><p>用客户端连接Zookeeper服务端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># bin&#x2F;zkCli.sh</span><br></pre></td></tr></table></figure><p><img src="/img/Zookeeper/cli_linux.png" alt=""></p><p>到达此步骤表示已经全部安装完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Zookeeper" scheme="https://xiaozeng26.github.io/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化</title>
    <link href="https://xiaozeng26.github.io/2020/05/23/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://xiaozeng26.github.io/2020/05/23/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2020-05-23T01:40:54.000Z</published>
    <updated>2020-05-23T14:07:12.594Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Redis持久化有两种方式 : </p><ul><li>数据快照(RDB)</li><li>过程日志(AOF)</li></ul><h1 id="1-数据快照-RDB"><a href="#1-数据快照-RDB" class="headerlink" title="1. 数据快照(RDB)"></a>1. 数据快照(RDB)</h1><p>定义 : 将当前数据状态进行保存，快照形式，存储的是数据结果，存储格式简单，关注点在数据。</p><p>RDB启动方式有三种 :</p><ul><li>save指令</li><li>bgsave指令</li><li>save配置 </li></ul><h2 id="1-1-RDB启动方式–save指令"><a href="#1-1-RDB启动方式–save指令" class="headerlink" title="1.1 RDB启动方式–save指令"></a>1.1 RDB启动方式–save指令</h2><p>下面进行实操演示 : </p><p>开启Redis服务器后，使用客户端连接，</p><p><img src="/img/Redis/cli_start.png" alt=""></p><p>使用了<strong>save</strong>命令之后，会在data目录下生成dump.rdb文件 : </p><p><img src="/img/Redis/rdb.png" alt=""></p><ul><li>命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save</span><br></pre></td></tr></table></figure><ul><li><p>作用</p><p>​    手动执行一次保存操作</p></li></ul><h3 id="1-1-1-save指令相关配置"><a href="#1-1-1-save指令相关配置" class="headerlink" title="1.1.1 save指令相关配置"></a>1.1.1 save指令相关配置</h3><ul><li><p>dbfilename dump.rdb</p><p>​    说明 : 设置本地数据库文件名，默认为dump.rdb , 通常设置为dump-<strong>端口号</strong>.rdb</p></li><li><p>dir</p><p>​    说明: 设置存储.rdb文件的路径，例如redis根目录下的data</p></li><li><p>rdbcompression yes</p><p>​    说明 : 设置存储至本地数据库时是否压缩数据，默认为yes</p></li><li><p>rdbchecksum yes</p><p>​    说明 : 设置是否进行RDB文件格式校验，该校验过程在写文件或读文件过程中均执行。</p></li></ul><p>修改conf目录下的redis-6379.conf,添加参数 : </p><p><img src="/img/Redis/rdbFile.png" alt=""></p><p><strong>注意：</strong> 修改完配置文件后需要重启Redis服务才能生效。</p><p><img src="/img/Redis/restart.png" alt=""></p><p>然后，再次启动客户端执行save指令就会发现重新生成了dump-6379.rdb文件</p><p><img src="/img/Redis/reCli.png" alt=""></p><p><img src="/img/Redis/6379rdb.png" alt=""></p><p>所以，在执行save指令之后，就可以实现保存数据，重启一下Redis服务之后，之前的数据依旧会存在。</p><p><img src="/img/Redis/restartRedisServer.png" alt=""></p><p><img src="/img/Redis/inCli.png" alt=""></p><p>从以上图示可以看出，数据还是存在的。</p><p><strong>注意:</strong>save指令的执行有可能会阻塞当前Redis服务器，直到当前RDB过程完成为止，就有可能会造成长时间阻塞，<strong>线上环境不建议使用</strong>。</p><h2 id="1-2-RDB启动方式–bgsave指令"><a href="#1-2-RDB启动方式–bgsave指令" class="headerlink" title="1.2 RDB启动方式–bgsave指令"></a>1.2 RDB启动方式–bgsave指令</h2><ul><li>命令 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgsave</span><br></pre></td></tr></table></figure><ul><li><p>作用</p><p>​    手动启动后台保存操作，但不是立即执行</p></li></ul><h3 id="1-2-1-bgsave指令相关配置"><a href="#1-2-1-bgsave指令相关配置" class="headerlink" title="1.2.1 bgsave指令相关配置"></a>1.2.1 bgsave指令相关配置</h3><p>在前面的配置基础上，加一条参数即可，</p><ul><li><p>stop-writes-on-bgsave-error yes</p><p>​    说明 : 后台存储过程中如果出现错误时，是否停止保存操作</p></li></ul><h2 id="1-3-RDB启动方式–save配置"><a href="#1-3-RDB启动方式–save配置" class="headerlink" title="1.3 RDB启动方式–save配置"></a>1.3 RDB启动方式–save配置</h2><ul><li>配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save second changes</span><br></pre></td></tr></table></figure><ul><li><p>作用 </p><p>​    满足限定时间范围内key的变化数量达到指定数量即进行自动持久化</p></li><li><p>参数 </p><p>​    second : 限定时间范围</p><p>​    changes : 监控key的变化量</p></li><li><p>位置 </p><p>​    在conf文件中进行配置</p></li><li><p>例子</p><p>​    save  900  1</p><p>​    save   300  10</p></li></ul><p>**</p><h2 id="1-4-RDB三种启动方式的比较"><a href="#1-4-RDB三种启动方式的比较" class="headerlink" title="1.4 RDB三种启动方式的比较"></a>1.4 RDB三种启动方式的比较</h2><table><thead><tr><th align="center">方式</th><th align="center">save指令</th><th align="center">bgsave指令</th></tr></thead><tbody><tr><td align="center">读写</td><td align="center">同步</td><td align="center">异步</td></tr><tr><td align="center">阻塞客户端指令</td><td align="center">是</td><td align="center">否</td></tr><tr><td align="center">额外内存消耗</td><td align="center">否</td><td align="center">是</td></tr><tr><td align="center">启动新进程</td><td align="center">否</td><td align="center">是</td></tr></tbody></table><p><strong>注意 :  save配置在后台执行的还是bgsave操作,所以比较上就不列出来了。</strong></p><h2 id="1-5-RDB的优点与缺点"><a href="#1-5-RDB的优点与缺点" class="headerlink" title="1.5 RDB的优点与缺点"></a>1.5 RDB的优点与缺点</h2><p><strong>RDB优点</strong></p><ul><li>RDB是一个紧凑压缩的二进制文件，存储效率较高。</li><li>RDB恢复数据的速度比AOF快很多。</li></ul><p><strong>RDB缺点</strong></p><ul><li>无法做到实时持久化，丢失数据可能性较大。</li><li>bgsave指令的执行要进行fork操作创建子进程，性能会被消耗。</li></ul><h1 id="2-过程日志-AOF"><a href="#2-过程日志-AOF" class="headerlink" title="2. 过程日志(AOF)"></a>2. 过程日志(AOF)</h1><p>概念: 将数据的操作过程进行保存，日志形式，存储的是操作过程，存储格式复杂，关注点在数据的操作过程。</p><ul><li>AOF的主要作用是解决了数据持久化的实时性。</li></ul><h2 id="2-1-AOF写数据三种策略-appendfsync"><a href="#2-1-AOF写数据三种策略-appendfsync" class="headerlink" title="2.1 AOF写数据三种策略(appendfsync)"></a>2.1 AOF写数据三种策略(appendfsync)</h2><ul><li><p>always（每次）</p><p>​    每次写入操作均同步到AOF文件中，<strong>数据零误差,但性能较低</strong>，不建议使用。</p></li><li><p>everysec (每秒)</p><p>​    每秒将缓冲区中的指令同步到AOF文件中，<strong>数据准确性较高，性能较高</strong>，建议使用，也是默认配置。</p></li><li><p>no (系统控制)</p><p>​    由系统进行控制，整体过程<strong>不可控</strong>。</p></li></ul><h2 id="2-2-AOF功能开启"><a href="#2-2-AOF功能开启" class="headerlink" title="2.2 AOF功能开启"></a>2.2 AOF功能开启</h2><ul><li>配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes|no</span><br></pre></td></tr></table></figure><ul><li><p>作用</p><p>​    是否开启AOF持久化功能</p></li><li><p>配置</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always|everysec|no</span><br></pre></td></tr></table></figure><ul><li><p>作用</p><p>​    AOF写数据策略(从缓存中将数据写入aof文件)</p></li></ul><h2 id="2-3-AOF相关配置"><a href="#2-3-AOF相关配置" class="headerlink" title="2.3 AOF相关配置"></a>2.3 AOF相关配置</h2><ul><li>配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfilename filename</span><br></pre></td></tr></table></figure><ul><li><p>作用</p><p>​    AOF持久化文件名，默认文件名是appendonly.aof,建议配置为appendonly-端口号.aof</p></li><li><p>配置</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir</span><br></pre></td></tr></table></figure><ul><li><p>作用</p><p>​    AOF持久化文件保存的路径，与RDB持久化文件保存一致即可。</p></li></ul><h2 id="2-4-AOF重写"><a href="#2-4-AOF重写" class="headerlink" title="2.4 AOF重写"></a>2.4 AOF重写</h2><p>当命令不断的写入AOF文件中，文件就会越来越来大，AOF文件重写就能解决这个问题。</p><p>AOF文件重写 : 将对同一个数据的若干条指令执行结果转化成最终结果数据对应的指令进行记录。</p><h3 id="2-4-1-AOF重写方式"><a href="#2-4-1-AOF重写方式" class="headerlink" title="2.4.1 AOF重写方式"></a>2.4.1 AOF重写方式</h3><ul><li>手动重写</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgrewriteaof</span><br></pre></td></tr></table></figure><ul><li>自动重写</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-min-size size</span><br><span class="line">auto-aof-rewrite-percentage percentage</span><br></pre></td></tr></table></figure><p><strong>AOF自动重写方式</strong></p><ul><li>自动重写触发条件设置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-min-size size</span><br><span class="line">auto-aof-rewrite-percentage percent</span><br></pre></td></tr></table></figure><ul><li>自动重写触发的对比参数( 运行指令info Persistence获取具体信息)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aof_current_size</span><br><span class="line">aof_base_size</span><br></pre></td></tr></table></figure><ul><li>自动重写触发条件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aof_current_size &gt; auto_aof-rewrite-min-size</span><br><span class="line">(aof_current_size - aof_base_size)&#x2F;aof_base_size &gt;&#x3D; auto-aof-rewrite-percentage</span><br></pre></td></tr></table></figure><h1 id="3-RDB与AOF的区别"><a href="#3-RDB与AOF的区别" class="headerlink" title="3. RDB与AOF的区别"></a>3. RDB与AOF的区别</h1><table><thead><tr><th align="center">持久化方式</th><th align="center">RDB</th><th align="center">AOF</th></tr></thead><tbody><tr><td align="center">占用存储空间</td><td align="center">小(数据级 ： 压缩)</td><td align="center">大(指令集 : 重写)</td></tr><tr><td align="center">存储速度</td><td align="center">慢</td><td align="center">快</td></tr><tr><td align="center">恢复速度</td><td align="center">快</td><td align="center">慢</td></tr><tr><td align="center">数据安全性</td><td align="center">会丢失数据</td><td align="center">依据策略决定</td></tr><tr><td align="center">资源消耗</td><td align="center">高/重量级</td><td align="center">低/轻量级</td></tr><tr><td align="center">启动优先级</td><td align="center">低</td><td align="center">高</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Redis" scheme="https://xiaozeng26.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>基于Linux的Redis安装与启动</title>
    <link href="https://xiaozeng26.github.io/2020/05/22/%E5%9F%BA%E4%BA%8ELinux%E7%9A%84Redis%E5%AE%89%E8%A3%85%E4%B8%8E%E5%90%AF%E5%8A%A8/"/>
    <id>https://xiaozeng26.github.io/2020/05/22/%E5%9F%BA%E4%BA%8ELinux%E7%9A%84Redis%E5%AE%89%E8%A3%85%E4%B8%8E%E5%90%AF%E5%8A%A8/</id>
    <published>2020-05-22T04:37:31.000Z</published>
    <updated>2020-05-22T14:07:05.216Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-Linux中安装Redis"><a href="#1-Linux中安装Redis" class="headerlink" title="1. Linux中安装Redis"></a>1. Linux中安装Redis</h1><h2 id="1-1-下载"><a href="#1-1-下载" class="headerlink" title="1.1 下载"></a>1.1 下载</h2><p>进入Redis官网下载 : <a href="https://redis.io/download" target="_blank" rel="noopener">https://redis.io/download</a></p><h2 id="1-2-安装"><a href="#1-2-安装" class="headerlink" title="1.2 安装"></a>1.2 安装</h2><p>提示 : 安装redis时，首先要安装gcc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># yum -y install gcc</span><br><span class="line"># yum -y install gcc-c++</span><br></pre></td></tr></table></figure><p>安装步骤 : </p><ul><li>开启Linux，并用SecureCRT连接</li><li>在Linux的/opt目录下创建software、module文件夹</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mkdir &#x2F;opt&#x2F;software</span><br><span class="line"># mkdir &#x2F;opt&#x2F;module</span><br></pre></td></tr></table></figure><ul><li>将下载好的.tar.gz拖进Linux，按住alt+p进入文件传输窗口，cd进/opt/software目录，将文件直接拖入Linux即可</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cd &#x2F;opt&#x2F;software</span><br><span class="line"># pwd</span><br></pre></td></tr></table></figure><ul><li>将.tar.gz解压到/opt/module</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cd &#x2F;opt&#x2F;software</span><br><span class="line"># tar -zxvf redis-6.0.1.tar.gz -C &#x2F;opt&#x2F;module&#x2F;</span><br></pre></td></tr></table></figure><ul><li>进入解压后的redis目录,使用make命令进行编译</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cd &#x2F;opt&#x2F;module&#x2F;redis-6.0.1&#x2F;</span><br><span class="line"># make</span><br></pre></td></tr></table></figure><p>如果报了一下错误，说明gcc版本过低，要求gcc版本是5.3以上(可通过gcc -v查看版本)，需要升级版本再安装 : </p><p><img src="/img/Redis/error.png" alt=""></p><p>执行一下命令进行升级gcc ,升级至9.3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># yum -y install centos-release-scl</span><br><span class="line"># yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils</span><br><span class="line"># scl enable devtoolset-9 bash</span><br></pre></td></tr></table></figure><p>*<em>需要注意，scl命令启用只是临时的，退出shell或重启就会恢复原系统的gcc版本，如果要长期使用gcc 9.3的话 : *</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># echo &quot;source &#x2F;opt&#x2F;rh&#x2F;devtoolset-9&#x2F;enable&quot; &gt;&gt;&#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><p>升级之后再次编译即可</p><ul><li>进入src/目录，执行make install后显示以下信息表示安装成功 : </li></ul><p><img src="/img/Redis/install.png" alt=""></p><h1 id="2-Redis服务启动"><a href="#2-Redis服务启动" class="headerlink" title="2.Redis服务启动"></a>2.Redis服务启动</h1><h2 id="2-1-指定端口启动服务"><a href="#2-1-指定端口启动服务" class="headerlink" title="2.1 指定端口启动服务"></a>2.1 指定端口启动服务</h2><p>服务器端 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src]# redis-server --port 6380</span><br></pre></td></tr></table></figure><p>客户端 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src]# redis-cli -p 6380</span><br></pre></td></tr></table></figure><h2 id="2-2-指定配置文件启动服务"><a href="#2-2-指定配置文件启动服务" class="headerlink" title="2.2 指定配置文件启动服务"></a>2.2 指定配置文件启动服务</h2><p>将目录下的redis.conf配置文件简化的复制一份，以后就使用简化的配置文件 :</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat redis.conf | grep -v &quot;#&quot; | grep -v &quot;^$&quot; &gt; redis-6379.conf</span><br><span class="line"># vim redis-6379.conf</span><br></pre></td></tr></table></figure><p>将redis-6379.conf配置文件只保留核心的一些东西 : </p><p><img src="/img/Redis/conf.png" alt=""></p><ul><li>port  6379    ## 端口号</li><li>daemonize  yes    ##守护进程启动</li><li>logfile  “6379.log”    ## 日志文件</li><li>dir   /opt/module/redis-6.0.1/data    ## 生成文件后存放的目录</li></ul><p>服务器端启动 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-6.0.1]# redis-server redis-6379.conf</span><br></pre></td></tr></table></figure><p>执行命令后redis就在后台启动了，可通过进程命令查看是否已启动redis服务端 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ps -ef | grep redis-</span><br></pre></td></tr></table></figure><p><img src="/img/Redis/ps_redis.png" alt=""></p><p>客户端尝试连接 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># redis-cli</span><br></pre></td></tr></table></figure><p><img src="/img/Redis/attempt_conn.png" alt=""></p><h2 id="2-3-配置文件启动目录管理"><a href="#2-3-配置文件启动目录管理" class="headerlink" title="2.3 配置文件启动目录管理"></a>2.3 配置文件启动目录管理</h2><p>在使用redis-6379.conf配置文件可以启动成功，但是发现，每当需要新启一个redis服务，就新建一个配置文件，这样会导致redis根目录下比较杂乱，所以建议用一个目录进行管理配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-6.0.1]# mkdir conf</span><br><span class="line">redis-6.0.1]# mv redis-6379.conf conf&#x2F;</span><br></pre></td></tr></table></figure><p><img src="/img/Redis/mv.png" alt=""></p><p>服务器端启动 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># redis-server conf&#x2F;redis-6379.con</span><br></pre></td></tr></table></figure><p><img src="/img/Redis/conf_redis.png" alt=""></p><p>客户端启动 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># redis-cli</span><br></pre></td></tr></table></figure><p><strong>之后需要新启一个redis服务时，只需要将redis-6379.conf配置文件复制一份并改名字和内部端口号，日志文件名即可，例如: redis-6380.conf</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Redis" scheme="https://xiaozeng26.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis通用指令</title>
    <link href="https://xiaozeng26.github.io/2020/05/22/Redis%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>https://xiaozeng26.github.io/2020/05/22/Redis%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4/</id>
    <published>2020-05-22T02:20:56.000Z</published>
    <updated>2020-05-22T02:58:03.626Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Redis通用指令可以分两种 : </p><ul><li>key通用指令</li><li>数据库通用指令</li></ul><h1 id="1-key通用指令"><a href="#1-key通用指令" class="headerlink" title="1.key通用指令"></a>1.key通用指令</h1><h2 id="1-1-key基本操作"><a href="#1-1-key基本操作" class="headerlink" title="1.1 key基本操作"></a>1.1 key基本操作</h2><ul><li>删除指定key</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key</span><br></pre></td></tr></table></figure><ul><li>判断key是否存在</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists key</span><br></pre></td></tr></table></figure><ul><li>获取key的类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type key</span><br></pre></td></tr></table></figure><h2 id="1-2-key扩展操作"><a href="#1-2-key扩展操作" class="headerlink" title="1.2 key扩展操作"></a>1.2 key扩展操作</h2><ul><li>为指定key设置有效期</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expire key seconds</span><br><span class="line">pexpire key milliseconds</span><br><span class="line">expireat key timestamp</span><br><span class="line">pexpireat key milliseconds-timestamp</span><br></pre></td></tr></table></figure><ul><li>获取key的有效时间</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ttl key</span><br><span class="line">pttl key</span><br></pre></td></tr></table></figure><ul><li>将key从时效性转化为永久性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">persist key</span><br></pre></td></tr></table></figure><ul><li>查询key</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys pattern</span><br></pre></td></tr></table></figure><p><strong>查询规则</strong></p><p>？匹配一个任意字符    [] 匹配一个指定字符    * 匹配任意数量的任意字符</p><table><thead><tr><th>pattern</th><th>description</th></tr></thead><tbody><tr><td>keys *</td><td>查询所有</td></tr><tr><td>keys zhang*</td><td>查询所有以zhang开头</td></tr><tr><td>keys *san</td><td>查询所有以san结尾</td></tr><tr><td>keys ?????san</td><td>查询所有前面五个任意字符，后面以san结尾</td></tr><tr><td>keys user: ?</td><td>查询所有以user : 开头，最后一个字符任意</td></tr><tr><td>keys u[st]er : 1</td><td>查询所有以u开头，以er:1结尾，中间包含一个字母，s或t</td></tr></tbody></table><h2 id="1-3-key其他操作"><a href="#1-3-key其他操作" class="headerlink" title="1.3 key其他操作"></a>1.3 key其他操作</h2><ul><li>为key改名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rename key newkey</span><br><span class="line">renamenx key newkey</span><br></pre></td></tr></table></figure><ul><li>对所有key排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort</span><br></pre></td></tr></table></figure><ul><li>其他key通用操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help @generic</span><br></pre></td></tr></table></figure><h1 id="2-数据库通用指令"><a href="#2-数据库通用指令" class="headerlink" title="2.数据库通用指令"></a>2.数据库通用指令</h1><h2 id="2-1-db基本操作"><a href="#2-1-db基本操作" class="headerlink" title="2.1 db基本操作"></a>2.1 db基本操作</h2><ul><li>切换数据库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select index</span><br></pre></td></tr></table></figure><ul><li>其他操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br><span class="line">ping </span><br><span class="line">echo message</span><br></pre></td></tr></table></figure><h2 id="2-2-db相关操作"><a href="#2-2-db相关操作" class="headerlink" title="2.2 db相关操作"></a>2.2 db相关操作</h2><ul><li>数据移动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move key db</span><br></pre></td></tr></table></figure><ul><li>数据清除</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dbsize</span><br><span class="line">flushdb</span><br><span class="line">flushall</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Redis" scheme="https://xiaozeng26.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis的五大数据类型</title>
    <link href="https://xiaozeng26.github.io/2020/05/21/Redis%E7%9A%84%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://xiaozeng26.github.io/2020/05/21/Redis%E7%9A%84%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-05-21T02:25:03.000Z</published>
    <updated>2020-05-21T14:41:36.752Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis-的五大数据类型"><a href="#Redis-的五大数据类型" class="headerlink" title="Redis 的五大数据类型"></a>Redis 的五大数据类型</h1><p>Redis一般是不在Windows系统中操作，但是对于零基础的学习者来说，windows版的Redis能上手更快，之后还会出适用于企业级开发的Linux版Redis教程。</p><p>在学习Redis时，首先得在Windows中进行安装。</p><h1 id="1-Redis的Windows版安装使用"><a href="#1-Redis的Windows版安装使用" class="headerlink" title="1. Redis的Windows版安装使用"></a>1. Redis的Windows版安装使用</h1><p>下载地址 ： <a href="https://github.com/MSOpenTech/redis/tags" target="_blank" rel="noopener">https://github.com/MSOpenTech/redis/tags</a></p><p>下载解压后可以直接使用</p><p><img src="/img/Redis/download.png" alt=""></p><p>核心文件 : </p><ul><li>redis-server.exe                服务启动命令</li><li>redis-cli.exe                   客户端启动</li><li>redis.windows.conf       redis核心配置文件</li><li>redis-benchmark.exe    性能测试工具</li><li>redis-check-aof.exe       AOF文件修复工具</li><li>redis-check-dump.exe   RDB文件修复工具</li></ul><p>进入Redis的安装目录cmd启动Redis服务器和客户端 : </p><p><img src="/img/Redis/cmd.png" alt=""></p><p>服务端启动 : </p><p><img src="/img/Redis/redis-server.png" alt=""></p><p>端口(Port) : 6379</p><p>PID : 随机产生</p><p>客户端连接: </p><p><img src="/img/Redis/redis-cli.png" alt=""></p><p>在介绍Redis的五大数据类型之前，先要懂得一些基本操作</p><h1 id="2-Redis的基本操作"><a href="#2-Redis的基本操作" class="headerlink" title="2. Redis的基本操作"></a>2. Redis的基本操作</h1><p><strong>信息添加</strong></p><ul><li>功能 : 设置key,value数据</li><li>命令 : </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value</span><br></pre></td></tr></table></figure><ul><li>例 :</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set name zhangsan</span><br></pre></td></tr></table></figure><p><strong>信息查询</strong></p><ul><li>功能 :  根据key查询出对应的value，如果不存在，则返回空(nil)</li><li>命令 : </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get key</span><br></pre></td></tr></table></figure><ul><li>例 : </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get name</span><br></pre></td></tr></table></figure><p><strong>清屏命令</strong></p><ul><li>功能 ：清除屏幕信息</li><li>命令 :</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br></pre></td></tr></table></figure><p><strong>退出客户端命令</strong></p><ul><li>功能 : 退出客户端</li><li>命令 : </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p><strong>帮助命令</strong></p><ul><li>获取命令帮助文档，获取组中所有命令信息名称</li><li>命令 : </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">help 命令名称</span><br><span class="line">help @组名</span><br></pre></td></tr></table></figure><h1 id="3-Redis五大数据类型"><a href="#3-Redis五大数据类型" class="headerlink" title="3. Redis五大数据类型"></a>3. Redis五大数据类型</h1><p>Redis的五大数据类型分别是  ： </p><ul><li>string</li><li>hash</li><li>list</li><li>set</li><li>sorted_set</li></ul><h2 id="3-1-string"><a href="#3-1-string" class="headerlink" title="3.1 string"></a>3.1 string</h2><p>redis数据存储格式</p><ul><li>redis 就相当于一个Map，采用的是<strong>key : value</strong> 的形式存储数据。</li><li><strong>数据类型</strong>指的是存储的数据的类型，也就是value部分的类型，而key永远都是字符串。</li></ul><p><img src="/img/Redis/string.png" alt=""></p><h3 id="3-1-1-string-类型数据的基本操作"><a href="#3-1-1-string-类型数据的基本操作" class="headerlink" title="3.1.1 string 类型数据的基本操作"></a>3.1.1 string 类型数据的基本操作</h3><ul><li>添加/修改数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value</span><br></pre></td></tr></table></figure><ul><li>获取数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get key</span><br></pre></td></tr></table></figure><ul><li>删除数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key</span><br></pre></td></tr></table></figure><p>或</p><ul><li>添加/修改多个数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset key1 value1 key2 value2 ...</span><br></pre></td></tr></table></figure><ul><li>获取多个数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget key1 key2 ...</span><br></pre></td></tr></table></figure><ul><li>获取字符串长度</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strlen key</span><br></pre></td></tr></table></figure><ul><li>追加信息到原始信息后部(若信息不存在，则新建)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">append key value</span><br></pre></td></tr></table></figure><h3 id="3-1-2-string-类型数据的拓展操作"><a href="#3-1-2-string-类型数据的拓展操作" class="headerlink" title="3.1.2 string 类型数据的拓展操作"></a>3.1.2 string 类型数据的拓展操作</h3><ul><li>设置数值数据增加指定范围的值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">incr key </span><br><span class="line">incrby key increment</span><br><span class="line">incrbyfloat key increment</span><br></pre></td></tr></table></figure><ul><li>设置数值数据减少指定范围的值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decr key</span><br><span class="line">decrby key increment</span><br></pre></td></tr></table></figure><ul><li>设置数据具有指定的生命周期</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setex key seconds value</span><br><span class="line">psetex key milliseconds value</span><br></pre></td></tr></table></figure><h3 id="3-1-3-string-类型数据操作的注意事项"><a href="#3-1-3-string-类型数据操作的注意事项" class="headerlink" title="3.1.3 string 类型数据操作的注意事项"></a>3.1.3 string 类型数据操作的注意事项</h3><ul><li><p>数据操作不成功的反馈与数据正常操作之间的差异</p><p>① 表示运行结果是否成功</p><ul><li>(integer) 0  —&gt; false    失败</li><li>(integer) 1  —&gt; true     成功</li></ul><p>② 表示运行结果值</p><ul><li>(integer) 3  —&gt; 3     3个</li><li>(integer) 1  —&gt; 1     1个</li></ul></li><li><p>数据没获取到</p><p>​    (nil) ,相当于null</p></li><li><p>数据最大存储量</p><p>​    512MB</p></li></ul><h3 id="3-1-4-Key的设置约定"><a href="#3-1-4-Key的设置约定" class="headerlink" title="3.1.4 Key的设置约定"></a>3.1.4 Key的设置约定</h3><ul><li><p>数据库中的key命名惯例 : </p><p><strong>表名 : 主键名 : 主键值 : 字段名</strong></p></li></ul><p>eg :   order : id : xxxxx : name</p><h2 id="3-2-hash"><a href="#3-2-hash" class="headerlink" title="3.2 hash"></a>3.2 hash</h2><p>存储结构 : 一个存储空间保存多个键值对数据</p><p>hash类型 : 底层使用哈希表结构实现数据存储</p><p>图例 : </p><p><img src="/img/Redis/hash.png" alt=""></p><h3 id="3-2-1-hash类型数据的基本操作"><a href="#3-2-1-hash类型数据的基本操作" class="headerlink" title="3.2.1 hash类型数据的基本操作"></a>3.2.1 hash类型数据的基本操作</h3><ul><li>添加/修改数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hset key field value</span><br></pre></td></tr></table></figure><ul><li>获取数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hget key field</span><br><span class="line">hgetall key</span><br></pre></td></tr></table></figure><ul><li>删除数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdel key field1 [field2]</span><br></pre></td></tr></table></figure><p>或</p><ul><li>添加/修改多个数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset key field1 value1 field2 value2 ...</span><br></pre></td></tr></table></figure><ul><li>获取多个数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmget key field1 field2 ...</span><br></pre></td></tr></table></figure><ul><li>获取哈希表中字段的数量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hlen key</span><br></pre></td></tr></table></figure><ul><li>判断哈希表中是否存在指定的字段</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexists key field</span><br></pre></td></tr></table></figure><h3 id="3-2-2-hash类型数据的拓展操作"><a href="#3-2-2-hash类型数据的拓展操作" class="headerlink" title="3.2.2 hash类型数据的拓展操作"></a>3.2.2 hash类型数据的拓展操作</h3><ul><li>获取哈希表中所有的字段名或字段值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hkeys key</span><br><span class="line">hvals key</span><br></pre></td></tr></table></figure><ul><li>设置指定字段的数值数据增加指定范围的值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hincrby key field increment</span><br><span class="line">hincrbyfloat key field increment</span><br></pre></td></tr></table></figure><h2 id="3-3-list"><a href="#3-3-list" class="headerlink" title="3.3 list"></a>3.3 list</h2><p>存储结构 : 一个存储空间保存多个数据，且，通过数据可以体现出进入顺序。</p><p>list类型 : 保存多个数据，底层使用双向链表存储结构实现</p><p><img src="/img/Redis/twoList.png" alt=""></p><p>list数据类型图例 : </p><p><img src="/img/Redis/list.png" alt=""></p><h3 id="3-3-1-list类型数据的基本操作"><a href="#3-3-1-list类型数据的基本操作" class="headerlink" title="3.3.1 list类型数据的基本操作"></a>3.3.1 list类型数据的基本操作</h3><ul><li>添加/修改数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lpush key value1 [value2] ...</span><br><span class="line">rpush key value1 [value2] ...</span><br></pre></td></tr></table></figure><ul><li>获取数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lrange key start stop </span><br><span class="line">lindex key index</span><br><span class="line">llen key</span><br></pre></td></tr></table></figure><ul><li>获取并移除数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lpop key</span><br><span class="line">rpop key</span><br></pre></td></tr></table></figure><h3 id="3-3-2-list类型数据的拓展操作"><a href="#3-3-2-list类型数据的拓展操作" class="headerlink" title="3.3.2 list类型数据的拓展操作"></a>3.3.2 list类型数据的拓展操作</h3><ul><li>规定时间内获取并移除数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blpop key1 [key2] timeout</span><br><span class="line">brpop key1 [key2] timeout</span><br><span class="line">brpoplpush source desination timeout</span><br></pre></td></tr></table></figure><ul><li>移除指定数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrem key count value</span><br></pre></td></tr></table></figure><h2 id="3-4-set"><a href="#3-4-set" class="headerlink" title="3.4 set"></a>3.4 set</h2><p>set类型 : 与hash存储结构完全相同，仅存储键，不存储值(nil),并且值是不允许重复的。</p><p><img src="/img/Redis/set.png" alt=""></p><h3 id="3-4-1-set类型数据的基本操作"><a href="#3-4-1-set类型数据的基本操作" class="headerlink" title="3.4.1 set类型数据的基本操作"></a>3.4.1 set类型数据的基本操作</h3><ul><li>添加数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sadd key member1 [member2]</span><br></pre></td></tr></table></figure><ul><li>获取全部数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smembers key</span><br></pre></td></tr></table></figure><ul><li>删除数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem key member1 [member2]</span><br></pre></td></tr></table></figure><ul><li>获取集合的数据总量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scard key</span><br></pre></td></tr></table></figure><ul><li>判断集合中是否包含指定数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sismember key member</span><br></pre></td></tr></table></figure><h3 id="3-4-2-set类型数据的拓展操作"><a href="#3-4-2-set类型数据的拓展操作" class="headerlink" title="3.4.2 set类型数据的拓展操作"></a>3.4.2 set类型数据的拓展操作</h3><ul><li>随机获取集合中指定数量的数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srandmember key [count]</span><br></pre></td></tr></table></figure><ul><li>随机获取集合中的某个数据并将该数据移出集合</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spop key [count]</span><br></pre></td></tr></table></figure><ul><li>求两个集合的交、并、差集</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sinter key1 [key2]</span><br><span class="line">sunion key1 [key2]</span><br><span class="line">sdiff key1 [key2]</span><br></pre></td></tr></table></figure><ul><li>求两集合的交、并、差集并存储到指定集合中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sinterstore destination key1 [key2]</span><br><span class="line">sunionstore destination key1 [key2]</span><br><span class="line">sdiffstore destination key1 [key2]</span><br></pre></td></tr></table></figure><ul><li>将指定数据从原始集合中移动到目标集合中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smove source destination member</span><br></pre></td></tr></table></figure><h2 id="3-5-sorted-set"><a href="#3-5-sorted-set" class="headerlink" title="3.5 sorted_set"></a>3.5 sorted_set</h2><p>sorted_set类型 : 在set的存储结构基础上添加可排序字段</p><p>图示 : </p><p><img src="/img/Redis/sorted_set.png" alt=""></p><h3 id="3-5-1-sorted-set-类型数据的基本操作"><a href="#3-5-1-sorted-set-类型数据的基本操作" class="headerlink" title="3.5.1 sorted_set 类型数据的基本操作"></a>3.5.1 sorted_set 类型数据的基本操作</h3><ul><li>添加数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd key score1 member1 [score2 member2]</span><br></pre></td></tr></table></figure><ul><li>获取全部数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zrange key start stop [WITHSCORES]</span><br><span class="line">zrevrange key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure><ul><li>删除数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem key member [member ...]</span><br></pre></td></tr></table></figure><ul><li>按条件获取数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zrangebyscore key min max [WITHSCORES] [LIMIT]</span><br><span class="line">zrevrangebyscore key max min [WITHSCORES]</span><br></pre></td></tr></table></figure><ul><li>条件删除数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zremrangebyrank key start stop</span><br><span class="line">zremrangebyscore key min max</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><p>min与max用于限定搜索查询的条件</p></li><li><p>start与stop用于限定查询范围，作用于索引，表示开始和结束索引 </p></li><li><p>offset与count用于限定查询范围，作用于查询结果，表示开始位置和数据总量 </p></li><li><p>获取集合数据总量</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zcard key </span><br><span class="line">zcount key min max</span><br></pre></td></tr></table></figure><ul><li>集合交、并操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zinterstore destination numkeys key [key ...] </span><br><span class="line">zunionstore destination numkeys key [key ...]</span><br></pre></td></tr></table></figure><h3 id="3-5-2-sorted-set类型数据的拓展操作"><a href="#3-5-2-sorted-set类型数据的拓展操作" class="headerlink" title="3.5.2 sorted_set类型数据的拓展操作"></a>3.5.2 sorted_set类型数据的拓展操作</h3><ul><li>获取数据对应的索引(排名)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zrank key member</span><br><span class="line">zrevrank key member</span><br></pre></td></tr></table></figure><ul><li>score值获取与修改</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zscore key member</span><br><span class="line">zincrby key increment member</span><br></pre></td></tr></table></figure><ul><li>获取当前系统时间</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Redis" scheme="https://xiaozeng26.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Spring-rabbit的简单应用</title>
    <link href="https://xiaozeng26.github.io/2020/05/20/Spring-rabbit%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/"/>
    <id>https://xiaozeng26.github.io/2020/05/20/Spring-rabbit%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</id>
    <published>2020-05-20T14:50:24.000Z</published>
    <updated>2020-05-23T01:46:56.980Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-rabbit的简单应用"><a href="#Spring-rabbit的简单应用" class="headerlink" title="Spring-rabbit的简单应用"></a>Spring-rabbit的简单应用</h1><h2 id="1-创建Maven工程并导入依赖"><a href="#1-创建Maven工程并导入依赖" class="headerlink" title="1.创建Maven工程并导入依赖"></a>1.创建Maven工程并导入依赖</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework.amqp/spring-rabbit --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-rabbit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.2.2.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/com.rabbitmq/amqp-client --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.7.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/log4j/log4j --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.slf4j/slf4j-api --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.25&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.slf4j/slf4j-log4j12 --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.25&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h2 id="2-编写applicationContext-xml文件"><a href="#2-编写applicationContext-xml文件" class="headerlink" title="2. 编写applicationContext.xml文件"></a>2. 编写applicationContext.xml文件</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xmlns:rabbit=<span class="string">"http://www.springframework.org/schema/rabbit"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/rabbit</span></span><br><span class="line"><span class="string">                http://www.springframework.org/schema/rabbit/spring-rabbit-1.4.xsd</span></span><br><span class="line"><span class="string">                http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">                http://www.springframework.org/schema/beans/spring-beans-4.0.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 定义RabbitMQ的连接工厂 --&gt;</span><br><span class="line">    &lt;rabbit:connection-factory</span><br><span class="line">            id=<span class="string">"connectionFactory"</span></span><br><span class="line">            host=<span class="string">"localhost"</span></span><br><span class="line">            port=<span class="string">"5672"</span></span><br><span class="line">            virtual-host=<span class="string">"host100"</span></span><br><span class="line">            username=<span class="string">"admin"</span></span><br><span class="line">            password=<span class="string">"admin"</span></span><br><span class="line">    /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 定义Rabbit模板，指定连接工厂以及定义exchange --&gt;</span><br><span class="line">    &lt;rabbit:template id=<span class="string">"rabbitTemplate"</span> connection-factory=<span class="string">"connectionFactory"</span> exchange=<span class="string">"fanoutExchange"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- MQ的管理，包括队列，交换机声明等 --&gt;</span><br><span class="line">    &lt;rabbit:admin connection-factory=<span class="string">"connectionFactory"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 定义交换机 --&gt;</span><br><span class="line">    &lt;rabbit:fanout-exchange name=<span class="string">"fanoutExchange"</span> auto-declare=<span class="string">"true"</span>&gt;</span><br><span class="line">        &lt;rabbit:bindings&gt;</span><br><span class="line">            &lt;rabbit:binding queue="fanout_Queue"&gt;&lt;/rabbit:binding&gt;</span><br><span class="line">        &lt;/rabbit:bindings&gt;</span><br><span class="line">    &lt;/rabbit:fanout-exchange&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 定义队列 --&gt;</span><br><span class="line">    &lt;rabbit:queue name=<span class="string">"fanout_Queue"</span> auto-declare=<span class="string">"true"</span> durable=<span class="string">"true"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 监听队列 --&gt;</span><br><span class="line">    &lt;rabbit:listener-container connection-factory=<span class="string">"connectionFactory"</span>&gt;</span><br><span class="line">        &lt;rabbit:listener queue-names="fanout_Queue" ref="consumer" method="listen"&gt;&lt;/rabbit:listener&gt;</span><br><span class="line">    &lt;/rabbit:listener-container&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 消费者 --&gt;</span><br><span class="line">    &lt;bean id="consumer" class="com.self.rabbitmq.springrabbit.SpringRabbitConsumer"&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h2 id="3-读取配置文件，获取Rabbit模板对象-生产者"><a href="#3-读取配置文件，获取Rabbit模板对象-生产者" class="headerlink" title="3.读取配置文件，获取Rabbit模板对象(生产者)"></a>3.读取配置文件，获取Rabbit模板对象(生产者)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.rabbitmq.springrabbit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spring-rabbit</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringRabbitProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取配置文件</span></span><br><span class="line">        ClassPathXmlApplicationContext app = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</span><br><span class="line">        <span class="comment">//获取rabbitMQ模板</span></span><br><span class="line">        RabbitTemplate rabbitTemplate = app.getBean(<span class="string">"rabbitTemplate"</span>, RabbitTemplate<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">"Hello Spring-rabbit"</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);<span class="comment">//休眠1秒</span></span><br><span class="line">        app.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-消费者"><a href="#4-消费者" class="headerlink" title="4. 消费者"></a>4. 消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.rabbitmq.springrabbit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spring-Rabbit的消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringRabbitConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(String consumer)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"消费者 ： "</span> + consumer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出截图 : </p><p><img src="/img/RabbitMQ/SpringRabbit.png" alt=""></p><h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5.结论"></a>5.结论</h2><p>通过读取Spring的配置文件applicationContext.xml的形式，创建连接rabbitmq的连接工厂，并声明交换机与队列等。无需写大量的代码，只需要写配置文件即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="RabbitMQ" scheme="https://xiaozeng26.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ的交换机说明</title>
    <link href="https://xiaozeng26.github.io/2020/05/20/RabbitMQ%E7%9A%84%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%AF%B4%E6%98%8E/"/>
    <id>https://xiaozeng26.github.io/2020/05/20/RabbitMQ%E7%9A%84%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%AF%B4%E6%98%8E/</id>
    <published>2020-05-20T11:23:05.000Z</published>
    <updated>2020-05-20T13:54:35.906Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RabbitMQ-的交换机-转发器"><a href="#RabbitMQ-的交换机-转发器" class="headerlink" title="RabbitMQ 的交换机(转发器)"></a>RabbitMQ 的交换机(转发器)</h1><p>定义 ：交换机/转发器一方面它接受生产者的消息，另一方面向队列推送消息。</p><p>在RabbitMQ中，有三种有三种类型的交换机 : </p><ul><li>Fanout Exchange(不处理路由键)</li><li>Direct Exchange(处理路由键)</li><li>Topic Exchange(将路由键和某模式进行匹配)</li></ul><h1 id="1-Fanout-Exchange"><a href="#1-Fanout-Exchange" class="headerlink" title="1. Fanout Exchange"></a>1. Fanout Exchange</h1><p>模型 : </p><p><img src="/img/RabbitMQ/Fanout_Exchange.png" alt=""></p><p>其实由上图就可以很容易的知道 ：只需要将队列与交换机进行绑定，生产者发送消息到队列上后，都会被转发到与该交换机绑定的所有队列上，这就是<strong>不处理路由键</strong>。</p><h1 id="2-Direct-Exchange"><a href="#2-Direct-Exchange" class="headerlink" title="2. Direct Exchange"></a>2. Direct Exchange</h1><p>模型 : </p><p><img src="/img/RabbitMQ/direct_exchange.png" alt=""> </p><p><strong>处理路由键</strong>，需要将队列与交换机进行绑定，，要求该消息与一个特定的路由键完全匹配，这是一个完整的匹配。</p><p>例如，如果一个队列绑定到该交换机上要求路由键”dog”,则只有被标记为”dog”的消息才回被转发。</p><h1 id="3-Topic-Exchange"><a href="#3-Topic-Exchange" class="headerlink" title="3. Topic Exchange"></a>3. Topic Exchange</h1><p>模型 : </p><p><img src="/img/RabbitMQ/Topic_Exchange.png" alt=""></p><p>将队列绑定到一个模式上。</p><p>“#” 匹配一个或多个词，</p><p>“*” 匹配一个词</p><p>就是说，生产者方routingKey = goods.add,存在有消费者1routingKey = good.delete,消费者2的routingKey = goods.#，那么消息只会被消费者2获取，消费者1无法获取。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="RabbitMQ" scheme="https://xiaozeng26.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ的五种队列</title>
    <link href="https://xiaozeng26.github.io/2020/05/19/RabbitMQ%E7%9A%84%E4%BA%94%E7%A7%8D%E9%98%9F%E5%88%97/"/>
    <id>https://xiaozeng26.github.io/2020/05/19/RabbitMQ%E7%9A%84%E4%BA%94%E7%A7%8D%E9%98%9F%E5%88%97/</id>
    <published>2020-05-19T00:51:55.000Z</published>
    <updated>2020-05-20T11:00:50.430Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RabbitMQ的五种队列"><a href="#RabbitMQ的五种队列" class="headerlink" title="RabbitMQ的五种队列"></a>RabbitMQ的五种队列</h1><p>RabbitMQ五种队列分别是 :</p><ul><li>简单队列</li><li>工作模式</li><li>订阅模式</li><li>路由模式</li><li>主题模式</li></ul><h1 id="1-简单队列"><a href="#1-简单队列" class="headerlink" title="1.简单队列"></a>1.简单队列</h1><p>模型 ：</p><p><img src="/img/RabbitMQ/%E7%AE%80%E5%8D%95%E9%98%9F%E5%88%97.png" alt=""></p><p>P : 消息的生产者</p><p>红色 : 队列</p><p>C : 消息的消费者</p><p>生产者将消息发送到队列，消费者从队列中获取消息。</p><p>示例(创建maven工程) : </p><h3 id="1-1-导入依赖"><a href="#1-1-导入依赖" class="headerlink" title="1.1 导入依赖"></a>1.1 导入依赖</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/com.rabbitmq/amqp-client --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.7.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/log4j/log4j --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.slf4j/slf4j-api --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.25&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.slf4j/slf4j-log4j12 --&gt;</span></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.25&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="1-2-编写获取MQ连接的工具类"><a href="#1-2-编写获取MQ连接的工具类" class="headerlink" title="1.2 编写获取MQ连接的工具类"></a>1.2 编写获取MQ连接的工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.rabbitmq.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取MQ的连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置服务器地址，AMQP端口号，选择vhost,用户名密码</span></span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">"host100"</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-生产者发送消息到消息队列"><a href="#1-3-生产者发送消息到消息队列" class="headerlink" title="1.3 生产者发送消息到消息队列"></a>1.3 生产者发送消息到消息队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.rabbitmq.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.self.rabbitmq.utils.ConnectionUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单队列的生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"simple_QUEUE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从连接中创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列，生产者发送消息到队列，消费者从队列中获取消息；</span></span><br><span class="line">        <span class="keyword">boolean</span> durable = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> exclusive = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> autoDelete = <span class="keyword">false</span>;</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,durable,exclusive,autoDelete,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        String msg = <span class="string">"Hello Simple QUEUE!"</span>;</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(<span class="string">""</span>,QUEUE_NAME,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">        System.out.println(<span class="string">"------Producer send msg : "</span> + msg);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行main程序，后台输出： </p><p><img src="/img/RabbitMQ/SimpleProducer.png" alt=""></p><p>观察RabbitMQ服务器 发现出现了一个队列：</p><p><img src="/img/RabbitMQ/simpleQueues.png" alt=""> </p><p>手动从队列中获取消息 (点击队列名称进入队列): </p><p><img src="/img/RabbitMQ/NoAutogetMessage.png" alt=""></p><p>通过代码让消费者获取消息 : </p><h3 id="1-4-消费者从队列中获取消息"><a href="#1-4-消费者从队列中获取消息" class="headerlink" title="1.4 消费者从队列中获取消息"></a>1.4 消费者从队列中获取消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.rabbitmq.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.self.rabbitmq.utils.ConnectionUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单队列的消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"simple_QUEUE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列，这句在生产者中已经写，在这里其实不用写</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明consumer对象</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">//handleDelivery的作用 : 一旦有消息进入队列，就会触发这个方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">"[x] consumer '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        <span class="comment">//true : autoAck 是否自动应答</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/RabbitMQ/ConsumerGetMsg.png" alt=""></p><h3 id="1-5-上述方法的解析"><a href="#1-5-上述方法的解析" class="headerlink" title="1.5 上述方法的解析"></a>1.5 上述方法的解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(QUEUE_NAME,durable,exclusive,autoDelete,Map&lt;String,Object&gt; arguments);</span><br></pre></td></tr></table></figure><p>QUEUE_NAME : 队列名；</p><p>durable : 是否持久化，就是说在服务器重启时，能否存活；</p><p>exclusive : 是否是当前连接的专用队列；</p><p>autoDelete : 没有消费者时，是否自动删除；</p><p>arguments : 参数;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(String exchange,QUEUE_NAME,basicProperties,<span class="keyword">byte</span>[] body);</span><br></pre></td></tr></table></figure><p>exchange : 交换机</p><p>QUEUE_NAME : 队列名</p><p>basicProperties : 属性</p><p>byte[] body : 消息；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明consumer对象</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">//handleDelivery的作用 : 一旦有消息进入队列，就会触发这个方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//hadleDelivery中的body就是队列中的消息；</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//监听队列</span></span><br><span class="line"><span class="comment">//true : autoAck 是否自动应答</span></span><br><span class="line">channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br></pre></td></tr></table></figure><h3 id="1-6-简单队列的不足"><a href="#1-6-简单队列的不足" class="headerlink" title="1.6 简单队列的不足"></a>1.6 简单队列的不足</h3><p>耦合性高，生产消费一一对应(如果有多个消费者想都消费这个消息，就不行了)，队列名称变更时需要同时更改。</p><h1 id="2-工作模式"><a href="#2-工作模式" class="headerlink" title="2. 工作模式"></a>2. 工作模式</h1><p>模型 : </p><p><img src="/img/RabbitMQ/%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97.png" alt=""> </p><p>一个生产者、两个消费者</p><p>一个消息只能被一个消费者获取。</p><p>  分为两种方式 : Round-robin(轮询分发)和Fair dispatch(公平分发)</p><h3 id="2-1-轮询分发"><a href="#2-1-轮询分发" class="headerlink" title="2.1 轮询分发"></a>2.1 轮询分发</h3><p>生产者 : </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.rabbitmq.work;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.self.rabbitmq.utils.ConnectionUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工作模式的生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"work_QUEUE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**                    |---C1</span></span><br><span class="line"><span class="comment">     * P---------QUEUE-----|</span></span><br><span class="line"><span class="comment">     *                     |---C2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> TimeoutException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            String msg = <span class="string">"hello :"</span> + i;</span><br><span class="line">            System.out.println(<span class="string">"[WQ] producer : "</span> + msg);</span><br><span class="line"></span><br><span class="line">            channel.basicPublish(<span class="string">""</span>,QUEUE_NAME,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(i*<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者1 ： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.rabbitmq.work;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.self.rabbitmq.utils.ConnectionUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工作模式的消费者1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkConsumer1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"work_QUEUE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">//队列中一旦有消息，就会触发此方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"utf-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">"[1] Consumer get : "</span> + message);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"[1] done"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> autoAck = <span class="keyword">true</span>;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,autoAck,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者 2 ： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.rabbitmq.work;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.self.rabbitmq.utils.ConnectionUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工作模式的消费者2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkConsumer2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"work_QUEUE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">//队列中有消息时，触发该方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">                String message = <span class="keyword">new</span> String(body,<span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">"[2] consumer get : "</span> + message);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"[2] done"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> autoAck = <span class="keyword">true</span>;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,autoAck,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果截图如下 :</p><p><img src="/img/RabbitMQ/workConsumer1.png" alt=""> </p><p><img src="/img/RabbitMQ/workConsumer2.png" alt=""></p><p><img src="/img/RabbitMQ/workProducer.png" alt=""></p><p>结论 : </p><p>生产者将消息发送完成后，两个消费者获取的消息数是一样的，但是消息内容不一样；</p><p>这是一种轮询分发策略，就是不管谁忙着或谁清闲，都不会多给一个消息，任务消息是你一个我一个的发送；</p><h3 id="2-2-公平分发"><a href="#2-2-公平分发" class="headerlink" title="2.2 公平分发"></a>2.2 公平分发</h3><p>使用公平分发的两个条件 : </p><ul><li>使用chanel.basicQos(perfetch = 1) ： 限制发送给同一个消费者不得超过一条消息，每次只处理一条消息；</li><li>消费者方要关闭自动应答，改为手动应答；<ul><li>chanel.basicQos(1);</li><li>chanel.basicAck(envelope.getDeliveryTag,false);</li><li>boolean autoAck = false;</li></ul></li></ul><p>生产者 : </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.rabbitmq.workfair;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.self.rabbitmq.utils.ConnectionUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工作模式的生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"work_QUEUE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**                    |---C1</span></span><br><span class="line"><span class="comment">     * P---------QUEUE-----|</span></span><br><span class="line"><span class="comment">     *                     |---C2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> TimeoutException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 每一个消费者发送确认消息之前，消费队列不发送下一个消息给消费者，一次只处理一个消息</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 限制发送给同一个消费者不得超过一条消息</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> perfetchCount = <span class="number">1</span>;</span><br><span class="line">        channel.basicQos(perfetchCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            String msg = <span class="string">"hello :"</span> + i;</span><br><span class="line">            System.out.println(<span class="string">"[WQ] producer : "</span> + msg);</span><br><span class="line"></span><br><span class="line">            channel.basicPublish(<span class="string">""</span>,QUEUE_NAME,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(i*<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者1 ： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.rabbitmq.workfair;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.self.rabbitmq.utils.ConnectionUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工作模式的消费者1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkConsumer1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"work_QUEUE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);<span class="comment">//保证一次只分发一个</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">//队列中一旦有消息，就会触发此方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"utf-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">"[1] Consumer get : "</span> + message);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"[1] done"</span>);</span><br><span class="line"></span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,autoAck,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.rabbitmq.workfair;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.self.rabbitmq.utils.ConnectionUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工作模式的消费者2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkConsumer2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"work_QUEUE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);<span class="comment">//保证一次只处理一个消息</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">//队列中有消息时，触发该方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">                String message = <span class="keyword">new</span> String(body,<span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">"[2] consumer get : "</span> + message);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"[2] done"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//手动应答</span></span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,autoAck,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果截图 : </p><p><img src="/img/RabbitMQ/workProducerFair.png" alt=""></p><p><img src="/img/RabbitMQ/workConsumerFair1.png" alt=""></p><p><img src="/img/RabbitMQ/workConsumerFair2.png" alt=""></p><p>结论 ： </p><p>生产者将消息发送完成后，消费者1获取的消息数量较少，消费者2获取的消息数量较多；</p><p>简单来说，就是能者多劳，公平分发；</p><h1 id="3-订阅模式"><a href="#3-订阅模式" class="headerlink" title="3.订阅模式"></a>3.订阅模式</h1><p>我们之前学习的都是一个消息只能被一个消费者消费，那么如果我想发一个消息 能被多个消费者消费，这该怎么办？这时候我们就得用消息中的订阅模型 ： </p><p><img src="/img/RabbitMQ/%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B.png" alt=""></p><p>解读 ： </p><ol><li>1个生产者，多个消费者；</li><li>每一个消费者都有自己的一个队列；</li><li>生产者没有将消息直接发送到队列，而是发送到了交换机；</li><li>每一个队列都要与交换机进行绑定；</li><li>生产者发送消息，经过交换机，到达队列，实现一个消息被多个消费者获取的目的；</li></ol><p>生产者 : </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.rabbitmq.subscribe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.self.rabbitmq.utils.ConnectionUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订阅模式生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscribeProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"exchange_fanout"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机 fanout表示分发</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"fanout"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        String msg = <span class="string">"hello subscribe"</span>;</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME,<span class="string">""</span>,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">        System.out.println(<span class="string">"subscribe : "</span> + msg);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果 : </p><p><img src="/img/RabbitMQ/subscribe.png" alt=""></p><p>观察服务器可以发现存在一个交换机 : </p><p><img src="/img/RabbitMQ/exchange.png" alt=""></p><p>注意 : 交换机并没有存储数据的能力，所以在没有队列和交换机绑定时，交换机接收到的消息丢失。</p><p>消费者1 : </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.rabbitmq.subscribe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.self.rabbitmq.utils.ConnectionUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订阅模式的消费者1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscribeConsumer1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"subscribe_QUEUE_1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"exchange_fanout"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将队列跟交换机进行绑定</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保证消费者一次只能获取一个消息</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">//队列上有消息就触发此方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">"[1] subscribeConsumer : "</span> + msg);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"[1] done"</span>);</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">false</span>,consumer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者2 : </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.rabbitmq.subscribe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.self.rabbitmq.utils.ConnectionUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订阅模式的消费者2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscribeConsumer2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"subscribe_QUEUE_2"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"exchange_fanout"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将队列与交换机进行绑定</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保证消费者一次只能获取一条消息</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg = <span class="keyword">new</span> String(body,<span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">"[2] subscribeConsumer : "</span> + msg);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"[2] done"</span>);</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">false</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果截图 : </p><p><img src="/img/RabbitMQ/subscribeProducer.png" alt=""></p><p><img src="/img/RabbitMQ/subscribeConsumer1.png" alt=""></p><p><img src="/img/RabbitMQ/subscribeConsumer2.png" alt=""></p><p>查看RabbitMQ服务器页面可知j交换机绑定了两个队列 : </p><p><img src="/img/RabbitMQ/bind.png" alt=""></p><p>结论 : </p><p>将消息发送到交换机，队列与交换机进行绑定，并且每一个消费者对应一个队列，所以两个消费者都可以获取生产者发送给交换机的消息。</p><h1 id="4-路由模式"><a href="#4-路由模式" class="headerlink" title="4. 路由模式"></a>4. 路由模式</h1><p>模型  : </p><p><img src="/img/RabbitMQ/%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%9E%8B.png" alt=""></p><p>解读 ： </p><p>交换机(exchange) 和队列都会拥有一个路由键(routingKey),如果交换机的路由键和队列的路由键相匹配时，交换机才会将消息放入队列中。</p><p>(error或info等就是routingKey)</p><p>生产者 : </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.rabbitmq.routing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.self.rabbitmq.utils.ConnectionUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 路由模型的生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoutingProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"exchange_direct"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"direct"</span>);</span><br><span class="line"></span><br><span class="line">        String msg = <span class="string">"hello Routing"</span>;</span><br><span class="line"></span><br><span class="line">        String routingKey = <span class="string">"error"</span>;</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME,routingKey,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"RoutingProducer : "</span> + msg);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者1: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.rabbitmq.routing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.self.rabbitmq.utils.ConnectionUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 路由模式的消费者1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoutingConsumer1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"exchange_direct"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"routing_QUEUE_1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">"error"</span>);</span><br><span class="line"></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg = <span class="keyword">new</span> String(body,<span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">"[1] routingConsumer : "</span> + msg);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"[1] done"</span>);</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">false</span>,consumer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者2 : </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.rabbitmq.routing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.self.rabbitmq.utils.ConnectionUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 路由模式的消费者2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoutingConsumer2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"routing_QUEUE_2"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"exchange_direct"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将队列与交换机进行绑定</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">"error"</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">"info"</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">"warning"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费者每一次只能获取一条信息</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg = <span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">"[2] RoutingConsumer : "</span> + msg);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"[2] done"</span>);</span><br><span class="line">                    <span class="comment">//手动回执</span></span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">false</span>,consumer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果截图 : </p><p><img src="/img/RabbitMQ/routingRoducer1.png" alt=""></p><p><img src="/img/RabbitMQ/routingConsumer1_1.png" alt=""></p><p><img src="/img/RabbitMQ/routingConsumer2_1.png" alt=""></p><p>由输出结果可知，当路由键设置成error时，两个消费者都可以获取到消息；</p><p>而当将生产者中的routingKey更改为info时，消费者1获取不到消息，只有将队列中的routingKey绑定有info发消费者2才能获取到消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String routingKey = <span class="string">"info"</span>;</span><br></pre></td></tr></table></figure><p><img src="/img/RabbitMQ/routingProducer2.png" alt=""></p><p><img src="/img/RabbitMQ/routingConsumer1_2.png" alt=""></p><p><img src="/img/RabbitMQ/routingConsumer2_2.png" alt=""></p><p>结论：路由模式中，交换机的routingKey和队列的routingKey是存在有对应关系的，可以在队列中绑定多个routingKey，而只有交换机和队列中的routingKey相互匹配才能获取消息。</p><h1 id="5-主题模式"><a href="#5-主题模式" class="headerlink" title="5. 主题模式"></a>5. 主题模式</h1><p>模型 ： </p><p><img src="/img/RabbitMQ/%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%BC%8F.png" alt=""></p><p>将路由键与某模式进行匹配</p><ul><li>#表示匹配一个或多个</li><li>*表示匹配一个</li></ul><p>生产者 ： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.rabbitmq.topic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.self.rabbitmq.utils.ConnectionUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题模式的生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"topic_EXCHANGE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"topic"</span>);</span><br><span class="line"></span><br><span class="line">        String msg = <span class="string">"商品..."</span>;</span><br><span class="line"></span><br><span class="line">        String routingKey = <span class="string">"goods.add"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送消息给交换机</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, routingKey,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">        System.out.println(<span class="string">"TopicProducer : "</span> + msg);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者1 : </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.rabbitmq.topic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.self.rabbitmq.utils.ConnectionUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题模式的消费者1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicConsumer1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"topic_QUEUE_1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"topic_EXCHANGE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将队列与交换机进行绑定</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">"goods.add"</span>);</span><br><span class="line"></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg = <span class="keyword">new</span> String(body,<span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">"[1] topicConsumer : "</span> + msg);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"[1] done"</span>);</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">false</span>,consumer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者 2 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.self.rabbitmq.topic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.self.rabbitmq.utils.ConnectionUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题模式的消费者1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicConsumer2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"topic_QUEUE_2"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"topic_EXCHANGE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">//创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将队列与交换机进行绑定</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">"goods.#"</span>);</span><br><span class="line"></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg = <span class="keyword">new</span> String(body,<span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">"[2] topicConsumer : "</span> + msg);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"[2] done"</span>);</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">false</span>,consumer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果截图 : </p><p><img src="/img/RabbitMQ/topicProducer.png" alt=""></p><p><img src="/img/RabbitMQ/topicConsumer1.png" alt=""></p><p><img src="/img/RabbitMQ/topicConsumer2.png" alt=""></p><p>由以上可以知道，当交换机中的routingKey = “goods.add”时，消费者1的队列中的routingKey = goods.add和消费者2的队列中的routingKey = goods.# 都是可以相互匹配的，所以两个消费者均可获取消息。</p><p>然后将生产者中的routingKey改成 routingKey = “good.delete时，消费者1的队列中的routingKey将没办法与交换机中的routingKey相匹配，所以消费者1没法获取消息，结果如下： </p><p><img src="/img/RabbitMQ/topicProducer2.png" alt=""></p><p><img src="/img/RabbitMQ/topicConsumer1_2.png" alt=""></p><p><img src="/img/RabbitMQ/topicConsumer2_2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="RabbitMQ" scheme="https://xiaozeng26.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Docker常用命令</title>
    <link href="https://xiaozeng26.github.io/2020/05/16/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://xiaozeng26.github.io/2020/05/16/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2020-05-16T03:50:44.000Z</published>
    <updated>2020-05-16T12:02:44.453Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h1><p>Docker常用命令可以分为三类 : </p><ul><li>Docker帮助命令 ： 3个<ul><li>docker version                    查看docker的版本</li><li>docker info                       显示docker的信息              </li><li>docker –help                    docker的帮助手册</li></ul></li><li>Docker镜像命令 ： 4个<ul><li>docker images                  显示本地主机的镜像</li><li>docker search 镜像名      搜索镜像</li><li>docker pull 镜像名           拉取镜像 </li><li>docker rmi 镜像名ID        删除镜像</li></ul></li><li>Docker容器命令 ： 8个<pre><code>* docker run [options] image                 运行镜像生成容器实例* docker ps [options]                              显示容器进程* exit                                                         容器停止退出 * docker start 容器ID或容器名               启动容器* docker restart 容器ID或容器名           重启容器* docker stop 容器ID或容器名               停止容器* docker kill 容器ID或容器名                  强制停止容器* docker rm 容器ID                                  删除容器</code></pre></li></ul><h2 id="1-Docker帮助命令"><a href="#1-Docker帮助命令" class="headerlink" title="1. Docker帮助命令"></a>1. Docker帮助命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker version</span><br></pre></td></tr></table></figure><p><img src="/img/docker/dockerversion.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker info</span><br></pre></td></tr></table></figure><p><img src="/img/docker/dockerInfo.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker --help</span><br></pre></td></tr></table></figure><p><img src="/img/docker/dockerHelp.png" alt=""></p><h2 id="2-Docker镜像命令"><a href="#2-Docker镜像命令" class="headerlink" title="2. Docker镜像命令"></a>2. Docker镜像命令</h2><h3 id="2-1-docker-images-options"><a href="#2-1-docker-images-options" class="headerlink" title="2.1 docker images [options]"></a>2.1 docker images [options]</h3><p>options:</p><ul><li>-a : 列出本地所有的镜像</li><li>-q : 只显示镜像ID</li><li>–digests :  显示镜像的摘要信息</li><li>–no-trunc :  显示完整的镜像信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker images -qa</span><br></pre></td></tr></table></figure><p><img src="/img/docker/dockerQA.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker images  -a --digests</span><br></pre></td></tr></table></figure><p><img src="/img/docker/dockerDigests.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker images -qa --no-trunc</span><br></pre></td></tr></table></figure><p><img src="/img/docker/dockerNo-Trunc.png" alt=""></p><h3 id="2-2-docker-search-options-镜像名"><a href="#2-2-docker-search-options-镜像名" class="headerlink" title="2.2 docker search [options] 镜像名"></a>2.2 docker search [options] 镜像名</h3><p>options : </p><ul><li>-s : 显示收藏数不小于指定值的镜像；</li><li>–no-trunc :  显示完整镜像描述；</li><li>–automated :  只显示automated build类型的镜像；</li></ul><p>下面是tomcat的收藏数不小于30并且是自动构建的完整镜像描述信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker search -s 30 --no-trunc --automated tomcat</span><br></pre></td></tr></table></figure><p><img src="/img/docker/dockerSearch.png" alt=""></p><h3 id="2-3-docker-pull-镜像名-Tag"><a href="#2-3-docker-pull-镜像名-Tag" class="headerlink" title="2.3 docker pull 镜像名[:Tag]"></a>2.3 docker pull 镜像名[:Tag]</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker pull mysql </span><br><span class="line"># docker images -a</span><br></pre></td></tr></table></figure><p><img src="/img/docker/pull.png" alt=""></p><p>注意：search 镜像是从Docker-Hub中搜索，而拉取镜像会从配置过的镜像源拉取(/etc/docker/daemon.json)，配置过程在上一篇“Docker理论知识点和安装”。</p><h3 id="2-4-docker-rmi-镜像名ID"><a href="#2-4-docker-rmi-镜像名ID" class="headerlink" title="2.4 docker rmi 镜像名ID"></a>2.4 docker rmi 镜像名ID</h3><p>删除操作就不做过多的演示，有兴趣的可以试试~~</p><p>删除单个镜像 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker rmi -f 镜像ID</span><br></pre></td></tr></table></figure><p>删除多个镜像 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker rmi -f 镜像名1:TAG 镜像名2:TAG</span><br></pre></td></tr></table></figure><p>删除全部镜像 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker rmi -f $(docker images -qa)</span><br></pre></td></tr></table></figure><h2 id="3-Docker容器命令"><a href="#3-Docker容器命令" class="headerlink" title="3. Docker容器命令"></a>3. Docker容器命令</h2><p>下面下载一个CentOS镜像进行演示 </p><h3 id="3-1-新建并运行容器-docker-run-options-images"><a href="#3-1-新建并运行容器-docker-run-options-images" class="headerlink" title="3.1 新建并运行容器 : docker  run [options] images"></a>3.1 新建并运行容器 : docker  run [options] images</h3><p>options : </p><ul><li>-it : 以交互模式运行容器，并分配一个伪输入终端</li><li>-d : 后台运行容器</li></ul><p>交互模式运行容器 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># docker run -it centos</span><br><span class="line"># pwd </span><br><span class="line"># ls -l</span><br></pre></td></tr></table></figure><p><img src="/img/docker/run.png" alt=""></p><h3 id="3-2-列出当前所有正在运行的容器-：-docker-ps-options"><a href="#3-2-列出当前所有正在运行的容器-：-docker-ps-options" class="headerlink" title="3.2 列出当前所有正在运行的容器 ： docker ps [options]"></a>3.2 列出当前所有正在运行的容器 ： docker ps [options]</h3><p>option : </p><ul><li>-a : 列出当前所有正在运行的容器 + 历史上运行过的；</li><li>-l : 显示最近创建的容器；</li><li>-n : 显示最近 n 个创建的容器；</li><li>-q : 只显示容器编号；</li><li>–no-trunc ：不截断输出</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker ps -a --no-trunc</span><br></pre></td></tr></table></figure><p><img src="/img/docker/dockerPsNo-trunc.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker ps -q -n 2 --no-trunc</span><br></pre></td></tr></table></figure><p><img src="/img/docker/dockerPsQN.png" alt=""></p><h2 id="3-3-退出容器"><a href="#3-3-退出容器" class="headerlink" title="3.3 退出容器"></a>3.3 退出容器</h2><p>两种方式 : </p><ul><li>exit   容器停止退出</li><li>Ctrl+P+Q   容器不停止退出</li></ul><h3 id="3-4-启动容器"><a href="#3-4-启动容器" class="headerlink" title="3.4 启动容器"></a>3.4 启动容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker start 容器ID或容器名</span><br></pre></td></tr></table></figure><h3 id="3-5-重启容器"><a href="#3-5-重启容器" class="headerlink" title="3.5 重启容器"></a>3.5 重启容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker restart 容器ID或容器名</span><br></pre></td></tr></table></figure><h3 id="3-6-停止容器"><a href="#3-6-停止容器" class="headerlink" title="3.6 停止容器"></a>3.6 停止容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker stop 容器ID或容器名</span><br></pre></td></tr></table></figure><h3 id="3-7-强制停止容器"><a href="#3-7-强制停止容器" class="headerlink" title="3.7  强制停止容器"></a>3.7  强制停止容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker kill 容器ID或容器名</span><br></pre></td></tr></table></figure><h3 id="3-8-删除已停止的容器"><a href="#3-8-删除已停止的容器" class="headerlink" title="3.8 删除已停止的容器"></a>3.8 删除已停止的容器</h3><p>删除一个 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker rm -f 容器ID</span><br></pre></td></tr></table></figure><p>删除多个 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker rm -f $(docker ps -qa)</span><br></pre></td></tr></table></figure><p>下面是比较重要的一些常用命令 : </p><h2 id="4-一些较重要的命令"><a href="#4-一些较重要的命令" class="headerlink" title="4. 一些较重要的命令"></a>4. 一些较重要的命令</h2><h3 id="4-1-启动守护式容器"><a href="#4-1-启动守护式容器" class="headerlink" title="4.1 启动守护式容器"></a>4.1 启动守护式容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker run -d centos</span><br></pre></td></tr></table></figure><p><img src="/img/docker/dockerRun.png" alt=""></p><p>注意：由上图可知，发现容器已经退出，Docker容器后台运行，就必须有一个前台进程；否则就会自动退出。</p><h3 id="4-2-查看容器日志-docker-logs-options-容器ID"><a href="#4-2-查看容器日志-docker-logs-options-容器ID" class="headerlink" title="4.2 查看容器日志  docker logs [options] 容器ID"></a>4.2 查看容器日志  docker logs [options] 容器ID</h3><p>option ： </p><ul><li>-t : 时间戳</li><li>-f : 跟随最新的日志打印</li><li>–tail 数字 ： 显示最后多少条</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker logs -tf --tail 容器ID</span><br></pre></td></tr></table></figure><h3 id="4-3-查看容器内运行的进程"><a href="#4-3-查看容器内运行的进程" class="headerlink" title="4.3 查看容器内运行的进程"></a>4.3 查看容器内运行的进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker top 容器ID</span><br></pre></td></tr></table></figure><h3 id="4-4-查看容器内部细节"><a href="#4-4-查看容器内部细节" class="headerlink" title="4.4 查看容器内部细节"></a>4.4 查看容器内部细节</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker inspect 容器ID</span><br></pre></td></tr></table></figure><h3 id="4-5-进入正在运行的容器并以命令行交互"><a href="#4-5-进入正在运行的容器并以命令行交互" class="headerlink" title="4.5 进入正在运行的容器并以命令行交互"></a>4.5 进入正在运行的容器并以命令行交互</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker exec -it 容器ID</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker attach 容器ID</span><br></pre></td></tr></table></figure><h3 id="4-6-从容器内拷贝文件到主机上"><a href="#4-6-从容器内拷贝文件到主机上" class="headerlink" title="4.6 从容器内拷贝文件到主机上"></a>4.6 从容器内拷贝文件到主机上</h3><ul><li>docker cp 容器ID : 容器内路径 目的主机路径</li></ul><p>实现 ：</p><p>​    运行镜像产生容器实例，在容器实例中创建shishi.txt，然后将容器中的shishi.txt拷贝到本地主机。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># docker ps -a </span><br><span class="line"># docker run -t centos</span><br><span class="line"># touch shishi.txt</span><br><span class="line"># ls</span><br><span class="line"></span><br><span class="line"># docker cp 12484b44e853:&#x2F;shishi.txt &#x2F;</span><br><span class="line"># cd &#x2F; </span><br><span class="line"># ls</span><br></pre></td></tr></table></figure><p><img src="/img/docker/dockerCp.png" alt=""></p><p><img src="/img/docker/dockerCp2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://xiaozeng26.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://xiaozeng26.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker的理论知识与安装</title>
    <link href="https://xiaozeng26.github.io/2020/05/15/Docker%E7%9A%84%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
    <id>https://xiaozeng26.github.io/2020/05/15/Docker%E7%9A%84%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E4%B8%8E%E5%AE%89%E8%A3%85/</id>
    <published>2020-05-15T02:57:07.000Z</published>
    <updated>2020-05-15T06:03:06.174Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-Docker的理论知识点"><a href="#1-Docker的理论知识点" class="headerlink" title="1. Docker的理论知识点"></a>1. Docker的理论知识点</h1><h2 id="1-1-什么是Docker？"><a href="#1-1-什么是Docker？" class="headerlink" title="1.1 什么是Docker？"></a>1.1 什么是Docker？</h2><p>Docker是一个开源的应用容器引擎，开发者可以将一些应用或依赖包打包成一个可移植的镜像，通过拉取(pull)的方式获取镜像并使用。</p><p>首先我们需要先了解Docker的三要素:</p><ul><li>镜像(Docker image) :   就是一个模板，用来创建Docker容器，一个镜像可以创建很多容器。</li><li>容器(Docker Container) : 容器就是镜像创建一个运行实例，每一个容器都是相互独立的，不会相互干扰。</li><li>仓库(Docker Repository) :  集中存放镜像文件的场所。可以分成公开仓库(Public)和私有仓库(Private),最大的公开仓库是<a href="https://hub.docker.com/" target="_blank" rel="noopener"> Docker Hub</a></li></ul><h2 id="1-2-Docker的架构"><a href="#1-2-Docker的架构" class="headerlink" title="1.2 Docker的架构"></a>1.2 Docker的架构</h2><p><img src="/img/docker%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt=""></p><ul><li>客户端 (Docker Client):  可以说就是操作Docker主机的一些命令操作，例如，docker pull,docker run等。</li><li>Docker主机(Docker Hosts) :  安装了Docker的机器，如CentOS7 。</li><li>仓库注册服务器(Registries) :  存有多个仓库，仓库中又包含有多个不同的image。  </li></ul><h1 id="2-Docker的安装"><a href="#2-Docker的安装" class="headerlink" title="2.Docker的安装"></a>2.Docker的安装</h1><p>官网</p><pre><code>* docker官网 :  &lt;http://www.docker.com&gt;* docker中文官网 :   &lt;https://www.docker-cn.com&gt;</code></pre><p>仓库</p><ul><li>Docker Hub 官网 : <a href="http://hub.docker.com" target="_blank" rel="noopener">http://hub.docker.com</a></li></ul><p>Docker支持一下的CentOS版本:</p><pre><code>* CentOS 7(64-bit)* CentOS 6.5(64-bit)以及更高版本</code></pre><p>以下是以CentOS 7 为例安装Docker : </p><h2 id="2-1-安装步骤"><a href="#2-1-安装步骤" class="headerlink" title="2.1 安装步骤"></a>2.1 安装步骤</h2><p>官网安装地址 : <a href="https://docs.docker.com/engine/install/centos/" target="_blank" rel="noopener">https://docs.docker.com/engine/install/centos/</a></p><ul><li>第一步，确定是否是CentOS 7及以上版本</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># cat &#x2F;etc&#x2F;redhat-release</span><br></pre></td></tr></table></figure><p>效果:</p><p><img src="/img/docker/redhat-release.png" alt=""></p><ul><li><p>第二步，yum安装gcc相关,首先就是CentOS 7必须要能连接外网</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum -y install gcc</span><br></pre></td></tr></table></figure><p>效果 : </p><p><img src="/img/docker/gcc.png" alt=""></p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum -y install gcc-c++</span><br></pre></td></tr></table></figure><p>效果 : </p><p><img src="/img/docker/gcc-c++.png" alt=""></p></li><li><p>第三步，若以前装有旧版本，可以先进行卸载</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#  yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><p>效果 : </p><p><img src="/img/docker/removeDocker.png" alt=""></p><p>因为为了方便演示，这是一台并没有装过Docker的CentOS 7，所以不删除任何软件包</p><ul><li>第四步，安装Docker依赖的软件包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum -y install yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>效果 : </p><p><img src="/img/docker/utilsPackage.png" alt=""></p><ul><li>第五步，设置稳定的镜像仓库，(注意 : 尽量不要使用官网上推荐的镜像仓库，有时候会导致拉取镜像失败),就是以下:</li></ul><p><img src="/img/docker/image.png" alt=""></p><p>推荐使用阿里云的镜像仓库 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#  yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure><p><img src="/img/docker/imageRepository.png" alt=""></p><ul><li>第六步，更新yum软件包索引</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum makecache fast</span><br></pre></td></tr></table></figure><p>效果 :</p><p><img src="/img/docker/update.png" alt=""></p><ul><li>第七步，安装Docker CE</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum -y install docker-ce</span><br></pre></td></tr></table></figure><p>效果 : </p><p><img src="/img/docker/success.png" alt=""></p><p>表示安装完成。</p><ul><li>第八步，启动docker</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># systemctl start docker</span><br><span class="line"># ps -ef | grep docker</span><br></pre></td></tr></table></figure><p>效果: </p><p><img src="/img/docker/start.png" alt=""></p><p>表示启动成功。</p><ul><li>第九步，测试一下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker version</span><br></pre></td></tr></table></figure><p><img src="/img/docker/version.png" alt=""></p><p>运行hello-world镜像，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker run hello-world</span><br></pre></td></tr></table></figure><p><img src="/img/docker/hello-world.png" alt=""></p><ul><li>第十步，配置镜像加速器，在daemon.json中加入阿里云镜像：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mkdir -p &#x2F;etc&#x2F;docker</span><br><span class="line"># vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;&#123;自己的编码&#125;.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 {自己的编码} 是每一个注册阿里云账号都会分配有一个镜像。例如：</p><p><img src="/img/docker/mirror.png" alt=""></p><p>保存退出之后重新加载，并重启docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># systemctl daemon-reload</span><br><span class="line"># systemctl restart docker</span><br></pre></td></tr></table></figure><p><img src="/img/docker/restart.png" alt=""></p><p>到此，docker安装就是完整的结束。</p><p>下面是卸载docker的命令，这里就不演示了，有兴趣可以试试~~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># systemctl stop docker </span><br><span class="line"># yum -y remove docker-ce</span><br><span class="line"># rm -rf &#x2F;var&#x2F;lib&#x2F;docker</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://xiaozeng26.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://xiaozeng26.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo创建的第一篇博客</title>
    <link href="https://xiaozeng26.github.io/2020/05/14/%E4%BD%BF%E7%94%A8hexo%E5%88%9B%E5%BB%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>https://xiaozeng26.github.io/2020/05/14/%E4%BD%BF%E7%94%A8hexo%E5%88%9B%E5%BB%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-05-14T02:48:52.000Z</published>
    <updated>2020-05-23T01:47:32.132Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>经过一段时间的折腾，完成了Hexo + GitHub搭建起了一个个人博客，一边学习一边写，弄出了第一篇的博客，心里美滋滋。</p><p>Hexo是一款”高效且简洁的博客框架”，但是它使用的是Markdown的规则，所以必须要学习Markdown的使用规则</p><h1 id="1-Markdown的基本使用"><a href="#1-Markdown的基本使用" class="headerlink" title="1.Markdown的基本使用"></a>1.Markdown的基本使用</h1><h2 id="1-1-斜体和粗体"><a href="#1-1-斜体和粗体" class="headerlink" title="1.1 斜体和粗体"></a>1.1 斜体和粗体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*这是斜体*</span><br><span class="line">**这是粗体**</span><br><span class="line">***这是加粗斜体***</span><br><span class="line">~~这是删除线~~</span><br></pre></td></tr></table></figure><p>效果:</p><p><em>这是斜体</em></p><p><strong>这是粗体</strong></p><p><strong><em>这是加粗斜体</em></strong></p><p><del>这是删除线</del></p><h2 id="1-2-分级标题"><a href="#1-2-分级标题" class="headerlink" title="1.2 分级标题"></a>1.2 分级标题</h2><p>写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p>效果：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h5 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h5><h2 id="1-3-超链接"><a href="#1-3-超链接" class="headerlink" title="1.3 超链接"></a>1.3 超链接</h2><p>写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">行内写法:[我的博客](https:&#x2F;&#x2F;xiaozeng26.github.io&#x2F;)</span><br><span class="line">自动链接:我的博客地址&lt;http:&#x2F;&#x2F;xiaozeng26.github.io&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>效果:</p><p>行内写法: <a href="https://xiaozeng26.github.io/">我的博客</a></p><p>自动链接: 我的博客地址<a href="https://xiaozeng26.github.io/">https://xiaozeng26.github.io/</a></p><h2 id="1-4-列表"><a href="#1-4-列表" class="headerlink" title="1.4 列表"></a>1.4 列表</h2><p>无序列表</p><p>写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 无序列表项1</span><br><span class="line">+ 无序列表项2</span><br><span class="line">- 无序列表项3</span><br></pre></td></tr></table></figure><p>效果:</p><ul><li>无序列表项1</li><li>无需列表项2</li><li>无需列表项3</li></ul><p>有序列表</p><p>写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 有序列表项1</span><br><span class="line">2. 有序列表项2</span><br><span class="line">3. 有序列表项3</span><br></pre></td></tr></table></figure><p>效果:</p><ol><li>有序列表项1 </li><li>有序列表项2</li><li>有序列表项3</li></ol><h2 id="1-5-插入图片"><a href="#1-5-插入图片" class="headerlink" title="1.5 插入图片"></a>1.5 插入图片</h2><p>注意: 在Hexo中插入图片，需要先将图片放在source/img/文件夹下，然后使用如下方式插入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](&#x2F;img&#x2F;insert_image.jpg)</span><br></pre></td></tr></table></figure><p>效果:</p><p><img src="/img/%E8%83%8C%E6%99%AF%E5%9B%BE.jpg" alt=""></p><h2 id="1-6-表格"><a href="#1-6-表格" class="headerlink" title="1.6 表格"></a>1.6 表格</h2><p>写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|国家|省份|市区|</span><br></pre></td></tr></table></figure><p>效果:</p><table><thead><tr><th>国家</th><th>省份</th><th>市区</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p>接下来是Hexo写博客的步骤方法:</p><h1 id="2-博客写作"><a href="#2-博客写作" class="headerlink" title="2. 博客写作"></a>2. 博客写作</h1><h2 id="2-1-配置文件命名规则和路由地址"><a href="#2-1-配置文件命名规则和路由地址" class="headerlink" title="2.1 配置文件命名规则和路由地址"></a>2.1 配置文件命名规则和路由地址</h2><p>Hexo默认以标题作为文件名称，可以通过修改Hexo的配置文件_config.yml中的new_post_name 参数来改变默认的文件名称，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_post_name: :year-:month-:day-:title.md</span><br></pre></td></tr></table></figure><p>当创建博客时，就会以这种格式生成Markdown文件，如这篇博客文件名就会生成为2020-05-14-使用hexo创建的第一篇博客 这种形式。其中相关变量说明如下:</p><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td>：title</td><td>标题（小写， 空格将会被替换为短杠）</td></tr><tr><td>:year</td><td>创建的年份，如：2020</td></tr><tr><td>:month</td><td>创建的月份（有前导零），如：05</td></tr><tr><td>:i_month</td><td>创建的月份（无前导零），如：1</td></tr><tr><td>:day</td><td>创建的日期（有前导零），如：09</td></tr><tr><td>:i_day</td><td>创建的月份（无前导零），如：9</td></tr></tbody></table><p>配置浏览器地址栏中的URL。同样是修改Hexo的配置文件_config.yml,其中的permalink属性，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permalink: &#x2F;blog&#x2F;:year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br></pre></td></tr></table></figure><p>当在地址栏访问时，就会呈现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:4000&#x2F;blog&#x2F;2020&#x2F;05&#x2F;14&#x2F;xxx&#x2F;</span><br></pre></td></tr></table></figure><h2 id="2-2-创建博客"><a href="#2-2-创建博客" class="headerlink" title="2.2 创建博客"></a>2.2 创建博客</h2><p>在命令行用如下命令创建博客:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>layout的选项:</p><table><thead><tr><th>布局(layout)</th><th>存储路径</th><th>说明</th></tr></thead><tbody><tr><td>post</td><td>source/_posts</td><td>默认，可以直接发布</td></tr><tr><td>page</td><td>source</td><td>在source下新建一个文件夹</td></tr><tr><td>draft</td><td>source/_drafts</td><td>新建文件将保持到_drafts中</td></tr></tbody></table><h2 id="3-写作"><a href="#3-写作" class="headerlink" title="3.写作"></a>3.写作</h2><p>经过上面的一系列工作之后，就可以打开source/_posts文件夹下刚建的Markdown文件，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 使用hexo创建的第一篇博客</span><br><span class="line">date: 2020-05-14 10:48:52</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>其中的tags可以配置多个，有两种写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tags: [tag1,tag2,tag3]</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tags:</span><br><span class="line">   - tag1</span><br><span class="line">   - tag2</span><br><span class="line">   - tag3</span><br></pre></td></tr></table></figure><p>接下来就可以进行博客的编写，完成博客的制作，当编写完成之后，需要在命令行窗口以下命令才能在网页上查看 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>最后将其部署到GitHub上:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>我们先是学习了Markdown的简单语法，然后记录了Hexo写博客的一些简单配置，并说明了博客的创建和部署。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="Hexo" scheme="https://xiaozeng26.github.io/tags/Hexo/"/>
    
      <category term="Markdown" scheme="https://xiaozeng26.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Spring中的环绕通知</title>
    <link href="https://xiaozeng26.github.io/2020/05/14/2020-05-14-Spring%E4%B8%AD%E7%9A%84%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5/"/>
    <id>https://xiaozeng26.github.io/2020/05/14/2020-05-14-Spring%E4%B8%AD%E7%9A%84%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5/</id>
    <published>2020-05-14T02:00:00.000Z</published>
    <updated>2020-05-14T06:55:28.755Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-的环绕通知"><a href="#Spring-的环绕通知" class="headerlink" title="Spring 的环绕通知"></a>Spring 的环绕通知</h1><p>定义：spring的环绕通知是Spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。</p><p>具体实现步骤：</p><ol><li>需要一个方法，并且这个方法的返回值是Object，传入一个ProceedingJoinPoint的参数。</li><li>在方法体中调用业务层方法(切入点方法)</li><li>最后返回调用结果</li></ol><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock Spring lang:java %&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundPrintLog</span><span class="params">(ProceedingJoinPoint pjp)</span></span>&#123;</span><br><span class="line">    object rtValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Object[] args = pjp.getArgs();<span class="comment">//获取方法执行所需参数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//前置通知</span></span><br><span class="line">        </span><br><span class="line">        rtValue = pjp.proceed(args);<span class="comment">//明确调用业务层方法(切入点方法)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//后置通知</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> rtValue;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Throwable t)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(t);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//异常通知</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="comment">//最终通知</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://xiaozeng26.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="https://xiaozeng26.github.io/tags/Spring/"/>
    
  </entry>
  
</feed>
