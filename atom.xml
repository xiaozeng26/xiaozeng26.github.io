<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小曾博客</title>
  
  <subtitle>IT Boy</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiaozeng26.github.io/"/>
  <updated>2020-05-16T11:58:40.963Z</updated>
  <id>https://xiaozeng26.github.io/</id>
  
  <author>
    <name>小曾</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker常用命令</title>
    <link href="https://xiaozeng26.github.io/2020/05/16/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://xiaozeng26.github.io/2020/05/16/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2020-05-16T03:50:44.000Z</published>
    <updated>2020-05-16T11:58:40.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h1><p>Docker常用命令可以分为三类 : </p><ul><li>Docker帮助命令 ： 3个<ul><li>docker version                    查看docker的版本</li><li>docker info                       显示docker的信息              </li><li>docker –help                    docker的帮助手册</li></ul></li><li>Docker镜像命令 ： 4个<ul><li>docker images                  显示本地主机的镜像</li><li>docker search 镜像名      搜索镜像</li><li>docker pull 镜像名           拉取镜像 </li><li>docker rmi 镜像名ID        删除镜像</li></ul></li><li>Docker容器命令 ： 8个<pre><code>* docker run [options] image                 运行镜像生成容器实例* docker ps [options]                              显示容器进程* exit                                                         容器停止退出 * docker start 容器ID或容器名               启动容器* docker restart 容器ID或容器名           重启容器* docker stop 容器ID或容器名               停止容器* docker kill 容器ID或容器名                  强制停止容器* docker rm 容器ID                                  删除容器</code></pre></li></ul><h2 id="1-Docker帮助命令"><a href="#1-Docker帮助命令" class="headerlink" title="1. Docker帮助命令"></a>1. Docker帮助命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker version</span><br></pre></td></tr></table></figure><p><img src="/img/docker/dockerversion.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker info</span><br></pre></td></tr></table></figure><p><img src="/img/docker/dockerInfo.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker --help</span><br></pre></td></tr></table></figure><p><img src="/img/docker/dockerHelp.png" alt=""></p><h2 id="2-Docker镜像命令"><a href="#2-Docker镜像命令" class="headerlink" title="2. Docker镜像命令"></a>2. Docker镜像命令</h2><h3 id="2-1-docker-images-options"><a href="#2-1-docker-images-options" class="headerlink" title="2.1 docker images [options]"></a>2.1 docker images [options]</h3><p>options:</p><ul><li>-a : 列出本地所有的镜像</li><li>-q : 只显示镜像ID</li><li>–digests :  显示镜像的摘要信息</li><li>–no-trunc :  显示完整的镜像信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker images -qa</span><br></pre></td></tr></table></figure><p><img src="/img/docker/dockerQA.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker images  -a --digests</span><br></pre></td></tr></table></figure><p><img src="/img/docker/dockerDigests.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker images -qa --no-trunc</span><br></pre></td></tr></table></figure><p><img src="/img/docker/dockerNo-Trunc.png" alt=""></p><h3 id="2-2-docker-search-options-镜像名"><a href="#2-2-docker-search-options-镜像名" class="headerlink" title="2.2 docker search [options] 镜像名"></a>2.2 docker search [options] 镜像名</h3><p>options : </p><ul><li>-s : 显示收藏数不小于指定值的镜像；</li><li>–no-trunc :  显示完整镜像描述；</li><li>–automated :  只显示automated build类型的镜像；</li></ul><p>下面是tomcat的收藏数不小于30并且是自动构建的完整镜像描述信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker search -s 30 --no-trunc --automated tomcat</span><br></pre></td></tr></table></figure><p><img src="/img/docker/dockerSearch.png" alt=""></p><h3 id="2-3-docker-pull-镜像名-Tag"><a href="#2-3-docker-pull-镜像名-Tag" class="headerlink" title="2.3 docker pull 镜像名[:Tag]"></a>2.3 docker pull 镜像名[:Tag]</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker pull mysql </span><br><span class="line"># docker images -a</span><br></pre></td></tr></table></figure><p><img src="/img/docker/pull.png" alt=""></p><p>注意：search 镜像是从Docker-Hub中搜索，而拉取镜像会从配置过的镜像源拉取(/etc/docker/daemon.json)，配置过程在上一篇“Docker理论知识点和安装”。</p><h3 id="2-4-docker-rmi-镜像名ID"><a href="#2-4-docker-rmi-镜像名ID" class="headerlink" title="2.4 docker rmi 镜像名ID"></a>2.4 docker rmi 镜像名ID</h3><p>删除操作就不做过多的演示，有兴趣的可以试试~~</p><p>删除单个镜像 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker rmi -f 镜像ID</span><br></pre></td></tr></table></figure><p>删除多个镜像 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker rmi -f 镜像名1:TAG 镜像名2:TAG</span><br></pre></td></tr></table></figure><p>删除全部镜像 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker rmi -f $(docker images -qa)</span><br></pre></td></tr></table></figure><h2 id="3-Docker容器命令"><a href="#3-Docker容器命令" class="headerlink" title="3. Docker容器命令"></a>3. Docker容器命令</h2><p>下面下载一个CentOS镜像进行演示 </p><h3 id="3-1-新建并运行容器-docker-run-options-images"><a href="#3-1-新建并运行容器-docker-run-options-images" class="headerlink" title="3.1 新建并运行容器 : docker  run [options] images"></a>3.1 新建并运行容器 : docker  run [options] images</h3><p>options : </p><ul><li>-it : 以交互模式运行容器，并分配一个伪输入终端</li><li>-d : 后台运行容器</li></ul><p>交互模式运行容器 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># docker run -it centos</span><br><span class="line"># pwd </span><br><span class="line"># ls -l</span><br></pre></td></tr></table></figure><p><img src="/img/docker/run.png" alt=""></p><h3 id="3-2-列出当前所有正在运行的容器-：-docker-ps-options"><a href="#3-2-列出当前所有正在运行的容器-：-docker-ps-options" class="headerlink" title="3.2 列出当前所有正在运行的容器 ： docker ps [options]"></a>3.2 列出当前所有正在运行的容器 ： docker ps [options]</h3><p>option : </p><ul><li>-a : 列出当前所有正在运行的容器 + 历史上运行过的；</li><li>-l : 显示最近创建的容器；</li><li>-n : 显示最近 n 个创建的容器；</li><li>-q : 只显示容器编号；</li><li>–no-trunc ：不截断输出</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker ps -a --no-trunc</span><br></pre></td></tr></table></figure><p><img src="/img/docker/dockerPsNo-trunc.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker ps -q -n 2 --no-trunc</span><br></pre></td></tr></table></figure><p><img src="/img/docker/dockerPsQN.png" alt=""></p><h2 id="3-3-退出容器"><a href="#3-3-退出容器" class="headerlink" title="3.3 退出容器"></a>3.3 退出容器</h2><p>两种方式 : </p><ul><li>exit   容器停止退出</li><li>Ctrl+P+Q   容器不停止退出</li></ul><h3 id="3-4-启动容器"><a href="#3-4-启动容器" class="headerlink" title="3.4 启动容器"></a>3.4 启动容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker start 容器ID或容器名</span><br></pre></td></tr></table></figure><h3 id="3-5-重启容器"><a href="#3-5-重启容器" class="headerlink" title="3.5 重启容器"></a>3.5 重启容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker restart 容器ID或容器名</span><br></pre></td></tr></table></figure><h3 id="3-6-停止容器"><a href="#3-6-停止容器" class="headerlink" title="3.6 停止容器"></a>3.6 停止容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker stop 容器ID或容器名</span><br></pre></td></tr></table></figure><h3 id="3-7-强制停止容器"><a href="#3-7-强制停止容器" class="headerlink" title="3.7  强制停止容器"></a>3.7  强制停止容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker kill 容器ID或容器名</span><br></pre></td></tr></table></figure><h3 id="3-8-删除已停止的容器"><a href="#3-8-删除已停止的容器" class="headerlink" title="3.8 删除已停止的容器"></a>3.8 删除已停止的容器</h3><p>删除一个 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker rm -f 容器ID</span><br></pre></td></tr></table></figure><p>删除多个 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker rm -f $(docker ps -qa)</span><br></pre></td></tr></table></figure><p>下面是比较重要的一些常用命令 : </p><h2 id="4-一些较重要的命令"><a href="#4-一些较重要的命令" class="headerlink" title="4. 一些较重要的命令"></a>4. 一些较重要的命令</h2><h3 id="4-1-启动守护式容器"><a href="#4-1-启动守护式容器" class="headerlink" title="4.1 启动守护式容器"></a>4.1 启动守护式容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker run -d centos</span><br></pre></td></tr></table></figure><p><img src="/img/docker/dockerRun.png" alt=""></p><p>注意：由上图可知，发现容器已经退出，Docker容器后台运行，就必须有一个前台进程；否则就会自动退出。</p><h3 id="4-2-查看容器日志-docker-logs-options-容器ID"><a href="#4-2-查看容器日志-docker-logs-options-容器ID" class="headerlink" title="4.2 查看容器日志  docker logs [options] 容器ID"></a>4.2 查看容器日志  docker logs [options] 容器ID</h3><p>option ： </p><ul><li>-t : 时间戳</li><li>-f : 跟随最新的日志打印</li><li>–tail 数字 ： 显示最后多少条</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker logs -tf --tail 容器ID</span><br></pre></td></tr></table></figure><h3 id="4-3-查看容器内运行的进程"><a href="#4-3-查看容器内运行的进程" class="headerlink" title="4.3 查看容器内运行的进程"></a>4.3 查看容器内运行的进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker top 容器ID</span><br></pre></td></tr></table></figure><h3 id="4-4-查看容器内部细节"><a href="#4-4-查看容器内部细节" class="headerlink" title="4.4 查看容器内部细节"></a>4.4 查看容器内部细节</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker inspect 容器ID</span><br></pre></td></tr></table></figure><h3 id="4-5-进入正在运行的容器并以命令行交互"><a href="#4-5-进入正在运行的容器并以命令行交互" class="headerlink" title="4.5 进入正在运行的容器并以命令行交互"></a>4.5 进入正在运行的容器并以命令行交互</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker exec -it 容器ID</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker attach 容器ID</span><br></pre></td></tr></table></figure><h3 id="4-6-从容器内拷贝文件到主机上"><a href="#4-6-从容器内拷贝文件到主机上" class="headerlink" title="4.6 从容器内拷贝文件到主机上"></a>4.6 从容器内拷贝文件到主机上</h3><ul><li>docker cp 容器ID : 容器内路径 目的主机路径</li></ul><p>实现 ：</p><p>​    运行镜像产生容器实例，在容器实例中创建shishi.txt，然后将容器中的shishi.txt拷贝到本地主机。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># docker ps -a </span><br><span class="line"># docker run -t centos</span><br><span class="line"># touch shishi.txt</span><br><span class="line"># ls</span><br><span class="line"></span><br><span class="line"># docker cp 12484b44e853:&#x2F;shishi.txt &#x2F;</span><br><span class="line"># cd &#x2F; </span><br><span class="line"># ls</span><br></pre></td></tr></table></figure><p><img src="/img/docker/dockerCp.png" alt=""></p><p><img src="/img/docker/dockerCp2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://xiaozeng26.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://xiaozeng26.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker的理论知识与安装</title>
    <link href="https://xiaozeng26.github.io/2020/05/15/Docker%E7%9A%84%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
    <id>https://xiaozeng26.github.io/2020/05/15/Docker%E7%9A%84%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E4%B8%8E%E5%AE%89%E8%A3%85/</id>
    <published>2020-05-15T02:57:07.000Z</published>
    <updated>2020-05-15T06:03:06.174Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-Docker的理论知识点"><a href="#1-Docker的理论知识点" class="headerlink" title="1. Docker的理论知识点"></a>1. Docker的理论知识点</h1><h2 id="1-1-什么是Docker？"><a href="#1-1-什么是Docker？" class="headerlink" title="1.1 什么是Docker？"></a>1.1 什么是Docker？</h2><p>Docker是一个开源的应用容器引擎，开发者可以将一些应用或依赖包打包成一个可移植的镜像，通过拉取(pull)的方式获取镜像并使用。</p><p>首先我们需要先了解Docker的三要素:</p><ul><li>镜像(Docker image) :   就是一个模板，用来创建Docker容器，一个镜像可以创建很多容器。</li><li>容器(Docker Container) : 容器就是镜像创建一个运行实例，每一个容器都是相互独立的，不会相互干扰。</li><li>仓库(Docker Repository) :  集中存放镜像文件的场所。可以分成公开仓库(Public)和私有仓库(Private),最大的公开仓库是<a href="https://hub.docker.com/" target="_blank" rel="noopener"> Docker Hub</a></li></ul><h2 id="1-2-Docker的架构"><a href="#1-2-Docker的架构" class="headerlink" title="1.2 Docker的架构"></a>1.2 Docker的架构</h2><p><img src="/img/docker%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt=""></p><ul><li>客户端 (Docker Client):  可以说就是操作Docker主机的一些命令操作，例如，docker pull,docker run等。</li><li>Docker主机(Docker Hosts) :  安装了Docker的机器，如CentOS7 。</li><li>仓库注册服务器(Registries) :  存有多个仓库，仓库中又包含有多个不同的image。  </li></ul><h1 id="2-Docker的安装"><a href="#2-Docker的安装" class="headerlink" title="2.Docker的安装"></a>2.Docker的安装</h1><p>官网</p><pre><code>* docker官网 :  &lt;http://www.docker.com&gt;* docker中文官网 :   &lt;https://www.docker-cn.com&gt;</code></pre><p>仓库</p><ul><li>Docker Hub 官网 : <a href="http://hub.docker.com" target="_blank" rel="noopener">http://hub.docker.com</a></li></ul><p>Docker支持一下的CentOS版本:</p><pre><code>* CentOS 7(64-bit)* CentOS 6.5(64-bit)以及更高版本</code></pre><p>以下是以CentOS 7 为例安装Docker : </p><h2 id="2-1-安装步骤"><a href="#2-1-安装步骤" class="headerlink" title="2.1 安装步骤"></a>2.1 安装步骤</h2><p>官网安装地址 : <a href="https://docs.docker.com/engine/install/centos/" target="_blank" rel="noopener">https://docs.docker.com/engine/install/centos/</a></p><ul><li>第一步，确定是否是CentOS 7及以上版本</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># cat &#x2F;etc&#x2F;redhat-release</span><br></pre></td></tr></table></figure><p>效果:</p><p><img src="/img/docker/redhat-release.png" alt=""></p><ul><li><p>第二步，yum安装gcc相关,首先就是CentOS 7必须要能连接外网</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum -y install gcc</span><br></pre></td></tr></table></figure><p>效果 : </p><p><img src="/img/docker/gcc.png" alt=""></p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum -y install gcc-c++</span><br></pre></td></tr></table></figure><p>效果 : </p><p><img src="/img/docker/gcc-c++.png" alt=""></p></li><li><p>第三步，若以前装有旧版本，可以先进行卸载</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#  yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><p>效果 : </p><p><img src="/img/docker/removeDocker.png" alt=""></p><p>因为为了方便演示，这是一台并没有装过Docker的CentOS 7，所以不删除任何软件包</p><ul><li>第四步，安装Docker依赖的软件包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum -y install yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>效果 : </p><p><img src="/img/docker/utilsPackage.png" alt=""></p><ul><li>第五步，设置稳定的镜像仓库，(注意 : 尽量不要使用官网上推荐的镜像仓库，有时候会导致拉取镜像失败),就是以下:</li></ul><p><img src="/img/docker/image.png" alt=""></p><p>推荐使用阿里云的镜像仓库 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#  yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure><p><img src="/img/docker/imageRepository.png" alt=""></p><ul><li>第六步，更新yum软件包索引</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum makecache fast</span><br></pre></td></tr></table></figure><p>效果 :</p><p><img src="/img/docker/update.png" alt=""></p><ul><li>第七步，安装Docker CE</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum -y install docker-ce</span><br></pre></td></tr></table></figure><p>效果 : </p><p><img src="/img/docker/success.png" alt=""></p><p>表示安装完成。</p><ul><li>第八步，启动docker</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># systemctl start docker</span><br><span class="line"># ps -ef | grep docker</span><br></pre></td></tr></table></figure><p>效果: </p><p><img src="/img/docker/start.png" alt=""></p><p>表示启动成功。</p><ul><li>第九步，测试一下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker version</span><br></pre></td></tr></table></figure><p><img src="/img/docker/version.png" alt=""></p><p>运行hello-world镜像，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker run hello-world</span><br></pre></td></tr></table></figure><p><img src="/img/docker/hello-world.png" alt=""></p><ul><li>第十步，配置镜像加速器，在daemon.json中加入阿里云镜像：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mkdir -p &#x2F;etc&#x2F;docker</span><br><span class="line"># vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;&#123;自己的编码&#125;.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 {自己的编码} 是每一个注册阿里云账号都会分配有一个镜像。例如：</p><p><img src="/img/docker/mirror.png" alt=""></p><p>保存退出之后重新加载，并重启docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># systemctl daemon-reload</span><br><span class="line"># systemctl restart docker</span><br></pre></td></tr></table></figure><p><img src="/img/docker/restart.png" alt=""></p><p>到此，docker安装就是完整的结束。</p><p>下面是卸载docker的命令，这里就不演示了，有兴趣可以试试~~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># systemctl stop docker </span><br><span class="line"># yum -y remove docker-ce</span><br><span class="line"># rm -rf &#x2F;var&#x2F;lib&#x2F;docker</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://xiaozeng26.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://xiaozeng26.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo创建的第一篇博客</title>
    <link href="https://xiaozeng26.github.io/2020/05/14/%E4%BD%BF%E7%94%A8hexo%E5%88%9B%E5%BB%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>https://xiaozeng26.github.io/2020/05/14/%E4%BD%BF%E7%94%A8hexo%E5%88%9B%E5%BB%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-05-14T02:48:52.000Z</published>
    <updated>2020-05-15T02:11:27.777Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>经过一段时间的折腾，完成了Hexo + GitHub搭建起了一个个人博客，一边学习一边写，弄出了第一篇的博客，心里美滋滋。</p><p>Hexo是一款”高效且简洁的博客框架”，但是它使用的是Markdown的规则，所以必须要学习Markdown的使用规则</p><h1 id="1-Markdown的基本使用"><a href="#1-Markdown的基本使用" class="headerlink" title="1.Markdown的基本使用"></a>1.Markdown的基本使用</h1><h2 id="1-1-斜体和粗体"><a href="#1-1-斜体和粗体" class="headerlink" title="1.1 斜体和粗体"></a>1.1 斜体和粗体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*这是斜体*</span><br><span class="line">**这是粗体**</span><br><span class="line">***这是加粗斜体***</span><br><span class="line">~~这是删除线~~</span><br></pre></td></tr></table></figure><p>效果:</p><p><em>这是斜体</em></p><p><strong>这是粗体</strong></p><p><strong><em>这是加粗斜体</em></strong></p><p><del>这是删除线</del></p><h2 id="1-2-分级标题"><a href="#1-2-分级标题" class="headerlink" title="1.2 分级标题"></a>1.2 分级标题</h2><p>写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p>效果：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h5 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h5><h2 id="1-3-超链接"><a href="#1-3-超链接" class="headerlink" title="1.3 超链接"></a>1.3 超链接</h2><p>写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">行内写法:[我的博客](https:&#x2F;&#x2F;xiaozeng26.github.io&#x2F;)</span><br><span class="line">自动链接:我的博客地址&lt;http:&#x2F;&#x2F;xiaozeng26.github.io&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>效果:</p><p>行内写法: <a href="https://xiaozeng26.github.io/">我的博客</a></p><p>自动链接: 我的博客地址<a href="https://xiaozeng26.github.io/">https://xiaozeng26.github.io/</a></p><h2 id="1-4-列表"><a href="#1-4-列表" class="headerlink" title="1.4 列表"></a>1.4 列表</h2><p>无序列表</p><p>写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 无序列表项1</span><br><span class="line">+ 无序列表项2</span><br><span class="line">- 无序列表项3</span><br></pre></td></tr></table></figure><p>效果:</p><ul><li>无序列表项1</li><li>无需列表项2</li><li>无需列表项3</li></ul><p>有序列表</p><p>写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 有序列表项1</span><br><span class="line">2. 有序列表项2</span><br><span class="line">3. 有序列表项3</span><br></pre></td></tr></table></figure><p>效果:</p><ol><li>有序列表项1 </li><li>有序列表项2</li><li>有序列表项3</li></ol><h2 id="1-5-插入图片"><a href="#1-5-插入图片" class="headerlink" title="1.5 插入图片"></a>1.5 插入图片</h2><p>注意: 在Hexo中插入图片，需要先将图片放在source/img/文件夹下，然后使用如下方式插入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](&#x2F;img&#x2F;insert_image.jpg)</span><br></pre></td></tr></table></figure><p>效果:</p><p><img src="/img/%E8%83%8C%E6%99%AF%E5%9B%BE.jpg" alt=""></p><h2 id="1-6-表格"><a href="#1-6-表格" class="headerlink" title="1.6 表格"></a>1.6 表格</h2><p>写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|国家|省份|市区|</span><br></pre></td></tr></table></figure><p>效果:</p><table><thead><tr><th>国家</th><th>省份</th><th>市区</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p>接下来是Hexo写博客的步骤方法:</p><h1 id="2-博客写作"><a href="#2-博客写作" class="headerlink" title="2. 博客写作"></a>2. 博客写作</h1><h2 id="2-1-配置文件命名规则和路由地址"><a href="#2-1-配置文件命名规则和路由地址" class="headerlink" title="2.1 配置文件命名规则和路由地址"></a>2.1 配置文件命名规则和路由地址</h2><p>Hexo默认以标题作为文件名称，可以通过修改Hexo的配置文件_config.yml中的new_post_name 参数来改变默认的文件名称，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_post_name: :year-:month-:day-:title.md</span><br></pre></td></tr></table></figure><p>当创建博客时，就会以这种格式生成Markdown文件，如这篇博客文件名就会生成为2020-05-14-使用hexo创建的第一篇博客 这种形式。其中相关变量说明如下:</p><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td>：title</td><td>标题（小写， 空格将会被替换为短杠）</td></tr><tr><td>:year</td><td>创建的年份，如：2020</td></tr><tr><td>:month</td><td>创建的月份（有前导零），如：05</td></tr><tr><td>:i_month</td><td>创建的月份（无前导零），如：1</td></tr><tr><td>:day</td><td>创建的日期（有前导零），如：09</td></tr><tr><td>:i_day</td><td>创建的月份（无前导零），如：9</td></tr></tbody></table><p>配置浏览器地址栏中的URL。同样是修改Hexo的配置文件_config.yml,其中的permalink属性，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permalink: &#x2F;blog&#x2F;:year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br></pre></td></tr></table></figure><p>当在地址栏访问时，就会呈现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:4000&#x2F;blog&#x2F;2020&#x2F;05&#x2F;14&#x2F;xxx&#x2F;</span><br></pre></td></tr></table></figure><h2 id="2-2-创建博客"><a href="#2-2-创建博客" class="headerlink" title="2.2 创建博客"></a>2.2 创建博客</h2><p>在命令行用如下命令创建博客:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>layout的选项:</p><table><thead><tr><th>布局(layout)</th><th>存储路径</th><th>说明</th></tr></thead><tbody><tr><td>post</td><td>source/_posts</td><td>默认，可以直接发布</td></tr><tr><td>page</td><td>source</td><td>在source下新建一个文件夹</td></tr><tr><td>draft</td><td>source/_drafts</td><td>新建文件将保持到_drafts中</td></tr></tbody></table><h2 id="3-写作"><a href="#3-写作" class="headerlink" title="3.写作"></a>3.写作</h2><p>经过上面的一系列工作之后，就可以打开source/_posts文件夹下刚建的Markdown文件，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 使用hexo创建的第一篇博客</span><br><span class="line">date: 2020-05-14 10:48:52</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>其中的tags可以配置多个，有两种写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tags: [tag1,tag2,tag3]</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tags:</span><br><span class="line">   - tag1</span><br><span class="line">   - tag2</span><br><span class="line">   - tag3</span><br></pre></td></tr></table></figure><p>接下来就可以进行博客的编写，完成博客的制作，当编写完成之后，需要在命令行窗口以下命令才能在网页上查看 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>最后将其部署到GitHub上:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>我们先是学习了Markdown的简单语法，然后记录了Hexo写博客的一些简单配置，并说明了博客的创建和部署。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="hexo" scheme="https://xiaozeng26.github.io/tags/hexo/"/>
    
      <category term="markdown" scheme="https://xiaozeng26.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>Spring中的环绕通知</title>
    <link href="https://xiaozeng26.github.io/2020/05/14/2020-05-14-Spring%E4%B8%AD%E7%9A%84%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5/"/>
    <id>https://xiaozeng26.github.io/2020/05/14/2020-05-14-Spring%E4%B8%AD%E7%9A%84%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5/</id>
    <published>2020-05-14T02:00:00.000Z</published>
    <updated>2020-05-14T06:55:28.755Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-的环绕通知"><a href="#Spring-的环绕通知" class="headerlink" title="Spring 的环绕通知"></a>Spring 的环绕通知</h1><p>定义：spring的环绕通知是Spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。</p><p>具体实现步骤：</p><ol><li>需要一个方法，并且这个方法的返回值是Object，传入一个ProceedingJoinPoint的参数。</li><li>在方法体中调用业务层方法(切入点方法)</li><li>最后返回调用结果</li></ol><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock Spring lang:java %&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundPrintLog</span><span class="params">(ProceedingJoinPoint pjp)</span></span>&#123;</span><br><span class="line">    object rtValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Object[] args = pjp.getArgs();<span class="comment">//获取方法执行所需参数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//前置通知</span></span><br><span class="line">        </span><br><span class="line">        rtValue = pjp.proceed(args);<span class="comment">//明确调用业务层方法(切入点方法)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//后置通知</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> rtValue;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Throwable t)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(t);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//异常通知</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="comment">//最终通知</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://xiaozeng26.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="https://xiaozeng26.github.io/tags/Spring/"/>
    
  </entry>
  
</feed>
